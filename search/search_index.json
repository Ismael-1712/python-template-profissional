{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"meu_projeto_placeholder","text":"<p>\ud83d\ude80 Template Python Profissional com Pipeline de Qualidade Integrado</p> <p> </p>"},{"location":"#bem-vindo-a-documentacao","title":"\ud83d\udcda Bem-vindo \u00e0 Documenta\u00e7\u00e3o","text":"<p>Este \u00e9 um template Python profissional que fornece uma base s\u00f3lida para desenvolvimento de projetos com:</p> <ul> <li>\u2705 Pipeline de Qualidade Integrado - CI/CD automatizado com GitHub Actions</li> <li>\u2705 Ferramentas Modernas - Ruff (linting + formata\u00e7\u00e3o), pytest, semantic-release</li> <li>\u2705 Documenta\u00e7\u00e3o Automatizada - MkDocs Material + mkdocstrings</li> <li>\u2705 Seguran\u00e7a e Auditoria - Sistema de code audit integrado</li> <li>\u2705 Git Sync Inteligente - Sincroniza\u00e7\u00e3o automatizada com valida\u00e7\u00e3o</li> </ul>"},{"location":"#quick-start","title":"\u26a1 Quick Start","text":"<pre><code># 1. Clone o reposit\u00f3rio\ngit clone https://github.com/usuario/meu_projeto_placeholder.git\ncd meu_projeto_placeholder\n\n# 2. Configure o ambiente (cria venv + instala depend\u00eancias)\nmake setup\n\n# 3. Ative o ambiente virtual\nsource .venv/bin/activate\n\n# 4. Valide a instala\u00e7\u00e3o\nmake test\n</code></pre> <p>Pronto! Voc\u00ea est\u00e1 preparado para desenvolver. \ud83c\udf89</p>"},{"location":"#comandos-de-engenharia","title":"\ud83d\udee0\ufe0f Comandos de Engenharia","text":"<p>Todos os comandos do projeto s\u00e3o gerenciados via Makefile para consist\u00eancia e automa\u00e7\u00e3o:</p> Comando Descri\u00e7\u00e3o <code>make setup</code> Configura ambiente completo (alias para <code>install-dev</code>) <code>make test</code> Executa suite completa de testes com pytest <code>make test-coverage</code> Testes com relat\u00f3rio de cobertura <code>make lint</code> Verifica c\u00f3digo com ruff (an\u00e1lise est\u00e1tica) <code>make format</code> Formata c\u00f3digo automaticamente com ruff <code>make audit</code> Auditoria completa de seguran\u00e7a e qualidade <code>make check</code> Valida\u00e7\u00e3o r\u00e1pida (lint + test) - use antes do push! <code>make docs-serve</code> Servidor de documenta\u00e7\u00e3o local <code>make docs-build</code> Build de documenta\u00e7\u00e3o para produ\u00e7\u00e3o <code>make release</code> (CI Only) Publica vers\u00e3o e gera changelog <code>make clean</code> Remove artefatos de build e cache <code>make help</code> Exibe todos os comandos dispon\u00edveis"},{"location":"#comandos-mais-usados","title":"\ud83c\udfaf Comandos Mais Usados","text":"<pre><code># Desenvolvimento do dia a dia\nmake format        # Formatar c\u00f3digo\nmake test          # Rodar testes\nmake check         # Valida\u00e7\u00e3o completa antes do commit\n\n# Pipeline de Qualidade Completo\nmake audit         # An\u00e1lise profunda de seguran\u00e7a\nmake test-coverage # Verificar cobertura de testes\n\n# Documenta\u00e7\u00e3o\nmake docs-serve    # Visualizar docs localmente\nmake docs-build    # Gerar site est\u00e1tico\n</code></pre>"},{"location":"#fluxo-de-trabalho-branches","title":"\ud83e\udd1d Fluxo de Trabalho &amp; Branches","text":""},{"location":"#politica-de-qualidade","title":"Pol\u00edtica de Qualidade","text":"<p>Regra de Ouro</p> <p>Nenhum c\u00f3digo \u00e9 aceito sem passar pelo <code>make audit</code> com sucesso.</p>"},{"location":"#estrategia-de-branches-automated-flow","title":"\ud83d\udd04 Estrat\u00e9gia de Branches (Automated Flow)","text":"<p>Este projeto utiliza um sistema de Auto-Propaga\u00e7\u00e3o para manter as variantes sincronizadas.</p> <ol> <li><code>main</code>: A fonte da verdade (Branch Protegida).</li> <li><code>api</code> / <code>cli</code>: Variantes geradas automaticamente.</li> </ol>"},{"location":"#navegacao-da-documentacao","title":"\ud83d\udcd6 Navega\u00e7\u00e3o da Documenta\u00e7\u00e3o","text":"<ul> <li>Refer\u00eancia da API - Documenta\u00e7\u00e3o autom\u00e1tica do c\u00f3digo</li> <li>Guias e Tutoriais - Documenta\u00e7\u00e3o t\u00e9cnica detalhada</li> <li>Code Audit - Sistema de auditoria de c\u00f3digo</li> <li>Contributing - Como contribuir para o projeto</li> </ul>"},{"location":"#sobre-este-template","title":"\ud83d\ude80 Sobre este Template","text":"<p>Este template foi desenvolvido com foco em:</p> <ul> <li>Qualidade de C\u00f3digo: An\u00e1lise est\u00e1tica rigorosa com Ruff</li> <li>Testes Automatizados: Cobertura de testes com pytest</li> <li>CI/CD Robusto: Pipeline completo com GitHub Actions</li> <li>Documenta\u00e7\u00e3o Viva: Docs as Code com MkDocs Material</li> <li>Seguran\u00e7a: Auditoria preventiva antes de commits</li> <li>Developer Experience: Comandos simples e consistentes via Makefile</li> </ul> <p>Documenta\u00e7\u00e3o gerada com \u2764\ufe0f por MkDocs Material</p>"},{"location":"AUDIT_DASHBOARD_INTEGRATION/","title":"Audit Dashboard Integration Guide","text":""},{"location":"AUDIT_DASHBOARD_INTEGRATION/#overview","title":"Overview","text":"<p>O <code>audit_dashboard.py</code> \u00e9 um sistema de m\u00e9tricas empresarial para rastreamento de auditorias DevOps, integrado com o <code>code_audit.py</code> para fornecer visibilidade completa sobre a efetividade das auditorias de CI/CD.</p>"},{"location":"AUDIT_DASHBOARD_INTEGRATION/#integration-points","title":"Integration Points","text":""},{"location":"AUDIT_DASHBOARD_INTEGRATION/#1-with-code_auditpy","title":"1. With <code>code_audit.py</code>","text":"<p>O dashboard pode ser integrado ao sistema de auditoria principal adicionando estas linhas ao final do <code>code_audit.py</code>:</p> <pre><code># Add to code_audit.py imports\nfrom scripts.audit_dashboard import AuditDashboard\n\n# Add to the end of your audit process\ndef integrate_dashboard_recording(audit_results: dict, workspace_root: Path):\n    \"\"\"Record audit results in dashboard metrics.\"\"\"\n    try:\n        dashboard = AuditDashboard(workspace_root)\n        dashboard.record_audit(audit_results)\n        logger.info(\"Audit metrics recorded successfully\")\n    except Exception as e:\n        logger.warning(f\"Failed to record audit metrics: {e}\")\n        # Don't fail the audit if dashboard recording fails\n</code></pre>"},{"location":"AUDIT_DASHBOARD_INTEGRATION/#2-cicd-pipeline-integration","title":"2. CI/CD Pipeline Integration","text":"<p>Add to your CI/CD pipeline (e.g., <code>.github/workflows/audit.yml</code>):</p> <pre><code>steps:\n  - name: Run Code Audit\n    run: python3 scripts/code_audit.py --output json --config scripts/audit_config.yaml\n\n  - name: Update Dashboard Metrics\n    run: python3 scripts/audit_dashboard.py\n\n  - name: Export Dashboard\n    run: python3 scripts/audit_dashboard.py --export-html\n\n  - name: Upload Dashboard Artifact\n    uses: actions/upload-artifact@v3\n    with:\n      name: audit-dashboard\n      path: audit_dashboard.html\n</code></pre>"},{"location":"AUDIT_DASHBOARD_INTEGRATION/#3-pre-commit-hook-integration","title":"3. Pre-commit Hook Integration","text":"<p>Add to <code>.pre-commit-config.yaml</code>:</p> <pre><code>repos:\n  - repo: local\n    hooks:\n      - id: audit-dashboard-update\n        name: Update Audit Dashboard\n        entry: python3 scripts/audit_dashboard.py\n        language: system\n        pass_filenames: false\n        stages: [post-commit]\n</code></pre>"},{"location":"AUDIT_DASHBOARD_INTEGRATION/#usage-examples","title":"Usage Examples","text":""},{"location":"AUDIT_DASHBOARD_INTEGRATION/#console-dashboard","title":"Console Dashboard","text":"<pre><code>python3 scripts/audit_dashboard.py\n</code></pre>"},{"location":"AUDIT_DASHBOARD_INTEGRATION/#html-export","title":"HTML Export","text":"<pre><code>python3 scripts/audit_dashboard.py --export-html\n</code></pre>"},{"location":"AUDIT_DASHBOARD_INTEGRATION/#json-export-for-monitoring","title":"JSON Export for Monitoring","text":"<pre><code>python3 scripts/audit_dashboard.py --export-json monitoring_metrics.json\n</code></pre>"},{"location":"AUDIT_DASHBOARD_INTEGRATION/#reset-statistics","title":"Reset Statistics","text":"<pre><code>python3 scripts/audit_dashboard.py --reset-stats\n</code></pre>"},{"location":"AUDIT_DASHBOARD_INTEGRATION/#monitoring-integration","title":"Monitoring Integration","text":""},{"location":"AUDIT_DASHBOARD_INTEGRATION/#prometheusgrafana","title":"Prometheus/Grafana","text":"<p>Export metrics to Prometheus format:</p> <pre><code>def export_prometheus_metrics(dashboard: AuditDashboard) -&gt; str:\n    \"\"\"Export metrics in Prometheus format.\"\"\"\n    metrics = dashboard.get_metrics_summary()\n\n    prometheus_metrics = f\"\"\"\n# HELP audit_total_performed Total number of audits performed\n# TYPE audit_total_performed counter\naudit_total_performed {metrics['audits_performed']}\n\n# HELP audit_failures_prevented Total number of failures prevented\n# TYPE audit_failures_prevented counter\naudit_failures_prevented {metrics['failures_prevented']}\n\n# HELP audit_time_saved_hours Total hours saved by audits\n# TYPE audit_time_saved_hours counter\naudit_time_saved_hours {metrics['time_saved_hours']}\n\n# HELP audit_success_rate Current audit success rate percentage\n# TYPE audit_success_rate gauge\naudit_success_rate {metrics['success_rate']}\n\"\"\"\n    return prometheus_metrics\n</code></pre>"},{"location":"AUDIT_DASHBOARD_INTEGRATION/#datadog-integration","title":"Datadog Integration","text":"<pre><code>def send_to_datadog(dashboard: AuditDashboard):\n    \"\"\"Send metrics to Datadog.\"\"\"\n    import datadog\n\n    metrics = dashboard.get_metrics_summary()\n\n    datadog.api.Metric.send([\n        {\n            'metric': 'devops.audit.performed',\n            'points': metrics['audits_performed']\n        },\n        {\n            'metric': 'devops.audit.failures_prevented',\n            'points': metrics['failures_prevented']\n        }\n    ])\n</code></pre>"},{"location":"AUDIT_DASHBOARD_INTEGRATION/#security-considerations","title":"Security Considerations","text":"<ol> <li>File Permissions: Dashboard automatically sets secure permissions (644) on generated files</li> <li>HTML Sanitization: All user data is sanitized before HTML output</li> <li>Atomic Writes: Metrics file updates use atomic writes to prevent corruption</li> <li>Thread Safety: All operations are thread-safe for concurrent usage</li> </ol>"},{"location":"AUDIT_DASHBOARD_INTEGRATION/#customization","title":"Customization","text":""},{"location":"AUDIT_DASHBOARD_INTEGRATION/#configure-time-estimation","title":"Configure Time Estimation","text":"<pre><code>dashboard = AuditDashboard(workspace_root)\n# Modify configuration\ndashboard._metrics[\"configuration\"][\"time_per_failure_minutes\"] = 10  # Custom time estimate\n</code></pre>"},{"location":"AUDIT_DASHBOARD_INTEGRATION/#custom-metrics-file-location","title":"Custom Metrics File Location","text":"<pre><code>dashboard = AuditDashboard(\n    workspace_root=Path(\"/custom/path\"),\n    metrics_filename=\"custom_metrics.json\"\n)\n</code></pre>"},{"location":"AUDIT_DASHBOARD_INTEGRATION/#troubleshooting","title":"Troubleshooting","text":""},{"location":"AUDIT_DASHBOARD_INTEGRATION/#common-issues","title":"Common Issues","text":"<ol> <li>Permission Denied: Ensure write permissions in workspace directory</li> <li>JSON Corruption: Dashboard creates backups automatically during reset</li> <li>Thread Safety: Use the provided RLock for custom modifications</li> </ol>"},{"location":"AUDIT_DASHBOARD_INTEGRATION/#log-analysis","title":"Log Analysis","text":"<p>Dashboard logs to both console and <code>audit_dashboard.log</code>:</p> <pre><code>tail -f audit_dashboard.log\n</code></pre>"},{"location":"AUDIT_DASHBOARD_INTEGRATION/#future-enhancements","title":"Future Enhancements","text":"<p>This dashboard is designed for the main branch of <code>python-template-profissional</code> and will work across:</p> <ul> <li><code>python-template-cli</code>: CLI applications</li> <li><code>python-template-api</code>: REST API services</li> <li><code>python-template-lib</code>: Library packages</li> </ul> <p>The dashboard provides universal DevOps metrics that are valuable regardless of project type.</p>"},{"location":"CODE_AUDIT/","title":"Code Security Auditor","text":"<p>Enterprise-grade security and quality auditing tool for Python projects. This tool performs static analysis to detect security vulnerabilities, external dependencies, and potential CI/CD issues before code commits.</p>"},{"location":"CODE_AUDIT/#features","title":"\ud83d\udd0d Features","text":"<ul> <li>Security Pattern Detection: Identifies dangerous patterns like <code>shell=True</code>, <code>os.system()</code>, and code injection risks</li> <li>External Dependency Analysis: Detects unmocked external services that can cause CI/CD failures</li> <li>Mock Coverage Analysis: Ensures proper mocking of external dependencies in tests</li> <li>CI Environment Simulation: Runs tests in CI-like conditions to catch environment-specific issues</li> <li>Configurable Rules: YAML-based configuration for custom security patterns and scan settings</li> <li>Multiple Output Formats: JSON and YAML report generation</li> <li>Pre-commit Integration: Seamless integration with git pre-commit hooks</li> <li>DevOps Best Practices: Follows enterprise security and maintainability standards</li> </ul>"},{"location":"CODE_AUDIT/#quick-start","title":"\ud83d\ude80 Quick Start","text":""},{"location":"CODE_AUDIT/#basic-usage","title":"Basic Usage","text":"<pre><code># Run basic security audit\npython scripts/code_audit.py\n\n# Use custom configuration\npython scripts/code_audit.py --config scripts/audit_config.yaml\n\n# Generate YAML report\npython scripts/code_audit.py --output yaml\n\n# Fail on medium severity issues\npython scripts/code_audit.py --fail-on MEDIUM\n</code></pre>"},{"location":"CODE_AUDIT/#security-patterns-detected","title":"\ud83d\udccb Security Patterns Detected","text":""},{"location":"CODE_AUDIT/#critical-severity","title":"Critical Severity","text":"<ul> <li><code>os.system()</code> - Command injection vulnerability</li> <li><code>shell=True</code> - Shell injection risk in subprocess calls</li> <li><code>eval()</code> - Code injection vulnerability</li> <li><code>exec()</code> - Code execution vulnerability</li> </ul>"},{"location":"CODE_AUDIT/#high-severity","title":"High Severity","text":"<ul> <li><code>subprocess.run()</code> without proper validation</li> <li><code>subprocess.call()</code> without proper validation</li> <li>Socket connections without mocking</li> <li><code>pickle.loads()</code> - Arbitrary code execution risk</li> </ul>"},{"location":"CODE_AUDIT/#medium-severity","title":"Medium Severity","text":"<ul> <li>HTTP requests without mocking (<code>requests.*</code>, <code>httpx.*</code>, <code>urllib.*</code>)</li> <li>Network operations in tests</li> </ul>"},{"location":"CODE_AUDIT/#low-severity","title":"Low Severity","text":"<ul> <li>File operations without proper error handling</li> </ul>"},{"location":"CODE_AUDIT/#configuration","title":"\u2699\ufe0f Configuration","text":"<p>The auditor uses a YAML configuration file (<code>audit_config.yaml</code>) to customize:</p> <ul> <li>Scan Paths: Directories to include in the audit</li> <li>File Patterns: File extensions to scan</li> <li>Exclude Paths: Directories to skip</li> <li>Security Patterns: Custom patterns to detect</li> <li>Severity Levels: Classification of findings</li> <li>Mock Indicators: Patterns that indicate proper mocking</li> </ul> <p>Example configuration:</p> <pre><code>scan_paths:\n  - \"src/\"\n  - \"tests/\"\n  - \"scripts/\"\n\nfile_patterns:\n  - \"*.py\"\n\nexclude_paths:\n  - \".git/\"\n  - \"__pycache__/\"\n  - \".venv/\"\n\nci_timeout: 300\nmax_findings_per_file: 50\n\ncustom_patterns:\n  - pattern: \"eval(\"\n    severity: \"CRITICAL\"\n    description: \"eval() usage detected - potential code injection\"\n    category: \"injection\"\n</code></pre>"},{"location":"CODE_AUDIT/#report-format","title":"\ud83d\udcca Report Format","text":"<p>The auditor generates comprehensive reports in JSON or YAML format:</p> <pre><code>{\n  \"metadata\": {\n    \"timestamp\": \"2025-10-31T10:00:00Z\",\n    \"workspace\": \"/path/to/project\",\n    \"duration_seconds\": 2.5,\n    \"files_scanned\": 42,\n    \"auditor_version\": \"2.0.0\"\n  },\n  \"findings\": [\n    {\n      \"file\": \"src/utils.py\",\n      \"line\": 15,\n      \"severity\": \"HIGH\",\n      \"category\": \"subprocess\",\n      \"description\": \"Subprocess execution detected\",\n      \"code\": \"subprocess.run(user_command, shell=True)\",\n      \"suggestion\": \"Use shell=False with list arguments\"\n    }\n  ],\n  \"summary\": {\n    \"total_findings\": 5,\n    \"severity_distribution\": {\n      \"CRITICAL\": 1,\n      \"HIGH\": 2,\n      \"MEDIUM\": 2,\n      \"LOW\": 0\n    },\n    \"overall_status\": \"FAIL\",\n    \"recommendations\": [\n      \"\ud83d\udd34 CRITICAL: Fix security vulnerabilities before commit\",\n      \"\ud83e\uddea Add mocks to 3 test files\"\n    ]\n  }\n}\n</code></pre>"},{"location":"CODE_AUDIT/#command-line-options","title":"\ud83d\udd27 Command Line Options","text":"<pre><code>python scripts/code_audit.py [OPTIONS]\n\nOptions:\n  --config PATH         Path to configuration YAML file\n  --output FORMAT       Output format: json, yaml (default: json)\n  --report-file PATH    Custom report output path\n  --quiet              Suppress console output\n  --fail-on SEVERITY   Exit with error on severity level: CRITICAL, HIGH, MEDIUM, LOW\n  --help               Show help message\n</code></pre>"},{"location":"CODE_AUDIT/#devops-integration","title":"\ud83c\udfd7\ufe0f DevOps Integration","text":""},{"location":"CODE_AUDIT/#cicd-pipeline-integration","title":"CI/CD Pipeline Integration","text":"<p>Add to your <code>.github/workflows/ci.yml</code>:</p> <pre><code>- name: Security Audit\n  run: |\n    python scripts/code_audit.py --fail-on HIGH --output json\n\n- name: Upload Audit Report\n  uses: actions/upload-artifact@v3\n  if: always()\n  with:\n    name: security-audit-report\n    path: audit_report_*.json\n</code></pre>"},{"location":"CODE_AUDIT/#docker-integration","title":"Docker Integration","text":"<pre><code># Add to your Dockerfile for development images\nCOPY scripts/code_audit.py /app/scripts/\nRUN pip install pyyaml\n\n# Run audit during build\nRUN python scripts/code_audit.py --fail-on CRITICAL\n</code></pre>"},{"location":"CODE_AUDIT/#security-best-practices","title":"\ud83d\udee1\ufe0f Security Best Practices","text":"<p>The auditor enforces these security principles:</p> <ol> <li>Input Validation: Detect unsafe user input handling</li> <li>Command Injection Prevention: Flag dangerous subprocess usage</li> <li>Dependency Isolation: Ensure external services are properly mocked</li> <li>Code Injection Prevention: Detect <code>eval()</code>, <code>exec()</code>, and similar risks</li> <li>Secure Defaults: Promote <code>shell=False</code> and safe coding patterns</li> </ol>"},{"location":"CODE_AUDIT/#performance","title":"\ud83d\udcc8 Performance","text":"<ul> <li>Fast Scanning: Processes ~1000 files/second</li> <li>Low Memory: Uses AST parsing for accuracy without high memory usage</li> <li>Configurable Limits: Prevents analysis paralysis with finding limits</li> <li>Early Exit: Stops on critical issues for fast feedback</li> </ul>"},{"location":"CODE_AUDIT/#contributing","title":"\ud83e\udd1d Contributing","text":"<p>When extending the auditor:</p> <ol> <li>Add new security patterns to <code>custom_patterns</code> in config</li> <li>Follow the <code>SecurityPattern</code> class structure</li> <li>Include severity classification and actionable suggestions</li> <li>Add corresponding tests for new patterns</li> <li>Update documentation with new capabilities</li> </ol>"},{"location":"CODE_AUDIT/#dependencies","title":"\ud83d\udcda Dependencies","text":"<ul> <li>Python 3.8+: Core language features and type hints</li> <li>PyYAML: Configuration file parsing</li> <li>Standard Library: AST, subprocess, pathlib, logging</li> </ul> <p>No heavy external dependencies - keeps the auditor lightweight and secure.</p>"},{"location":"CODE_AUDIT/#troubleshooting","title":"\ud83d\udd0d Troubleshooting","text":""},{"location":"CODE_AUDIT/#common-issues","title":"Common Issues","text":"<p>\"pytest not found\": Install pytest for CI simulation</p> <pre><code>pip install pytest pytest-timeout\n</code></pre> <p>\"Config file not found\": Use absolute path or place config in scripts/</p> <pre><code>python scripts/code_audit.py --config /full/path/to/config.yaml\n</code></pre> <p>\"Too many findings\": Adjust <code>max_findings_per_file</code> in config</p> <pre><code>max_findings_per_file: 20  # Reduce from default 50\n</code></pre> <p>\"False positives\": Add exclusion patterns or adjust severity thresholds</p> <pre><code>exclude_paths:\n  - \"tests/fixtures/\"  # Exclude test fixtures\n  - \"migrations/\"      # Exclude database migrations\n</code></pre>"},{"location":"CODE_AUDIT/#support","title":"\ud83d\udcde Support","text":"<p>For issues, feature requests, or questions:</p> <ol> <li>Check the configuration documentation</li> <li>Review the troubleshooting section</li> <li>Examine audit logs in <code>audit.log</code></li> <li>Create an issue with audit report attached</li> </ol>"},{"location":"P12_CODE_AUDIT_REFACTORING_ANALYSIS/","title":"P12 - An\u00e1lise de Refatora\u00e7\u00e3o do Code Audit","text":"<p>Data: 19 de Novembro de 2025 Tarefa: P12 - Refatora\u00e7\u00e3o de scripts/code_audit.py Fase: 01 - An\u00e1lise e Planejamento Status: \u2705 An\u00e1lise Completa</p>"},{"location":"P12_CODE_AUDIT_REFACTORING_ANALYSIS/#sumario-executivo","title":"\ud83d\udccb Sum\u00e1rio Executivo","text":"<p>O arquivo <code>scripts/code_audit.py</code> possui 535 linhas e implementa um sistema completo de auditoria de c\u00f3digo. Atualmente, \u00e9 um \"God Object\" que mistura m\u00faltiplas responsabilidades, dificultando manuten\u00e7\u00e3o, testes unit\u00e1rios e extensibilidade.</p> <p>M\u00e9tricas Atuais:</p> <ul> <li>3 Classes (SecurityPattern, AuditResult, CodeAuditor)</li> <li>4 Fun\u00e7\u00f5es Standalone (save_report, print_summary, main, main)</li> <li>Complexidade Ciclom\u00e1tica Estimada: Alta (&gt;15 em CodeAuditor)</li> <li>Acoplamento: Alto (tudo em um \u00fanico m\u00f3dulo)</li> <li>Testabilidade: Baixa (dif\u00edcil isolar responsabilidades)</li> </ul>"},{"location":"P12_CODE_AUDIT_REFACTORING_ANALYSIS/#parte-1-anatomia-atual-do-script","title":"\ud83d\udd0d PARTE 1: Anatomia Atual do Script","text":""},{"location":"P12_CODE_AUDIT_REFACTORING_ANALYSIS/#11-estrutura-geral","title":"1.1 Estrutura Geral","text":"<pre><code>code_audit.py (535 linhas)\n\u251c\u2500\u2500 Imports e Configura\u00e7\u00e3o de Logging (linhas 1-41)\n\u251c\u2500\u2500 Classe SecurityPattern (linhas 43-56)\n\u251c\u2500\u2500 Classe AuditResult (linhas 59-87)\n\u251c\u2500\u2500 Classe CodeAuditor (linhas 90-416)\n\u2502   \u251c\u2500\u2500 __init__ + _load_config\n\u2502   \u251c\u2500\u2500 _load_security_patterns\n\u2502   \u251c\u2500\u2500 _get_python_files\n\u2502   \u251c\u2500\u2500 _analyze_file\n\u2502   \u251c\u2500\u2500 _is_in_string_literal\n\u2502   \u251c\u2500\u2500 _generate_suggestion\n\u2502   \u251c\u2500\u2500 _check_mock_coverage\n\u2502   \u251c\u2500\u2500 _simulate_ci_environment\n\u2502   \u251c\u2500\u2500 run_audit\n\u2502   \u2514\u2500\u2500 _generate_recommendations\n\u251c\u2500\u2500 Fun\u00e7\u00e3o save_report (linhas 419-433)\n\u251c\u2500\u2500 Fun\u00e7\u00e3o print_summary (linhas 436-477)\n\u251c\u2500\u2500 Fun\u00e7\u00e3o main (linhas 480-564)\n\u2514\u2500\u2500 Entry Point __main__ (linhas 567-568)\n</code></pre>"},{"location":"P12_CODE_AUDIT_REFACTORING_ANALYSIS/#12-responsabilidades-identificadas","title":"1.2 Responsabilidades Identificadas","text":""},{"location":"P12_CODE_AUDIT_REFACTORING_ANALYSIS/#r1-configuracao-e-inicializacao","title":"R1: Configura\u00e7\u00e3o e Inicializa\u00e7\u00e3o","text":"<ul> <li><code>_load_config()</code> - Carrega configura\u00e7\u00e3o YAML com fallback defaults</li> <li><code>__init__()</code> - Inicializa auditor com workspace e config</li> <li>Gest\u00e3o de logging (linhas 32-41)</li> </ul> <p>Problema: Mistura l\u00f3gica de neg\u00f3cio com infraestrutura (I/O de config).</p>"},{"location":"P12_CODE_AUDIT_REFACTORING_ANALYSIS/#r2-definicao-de-modelos-de-dados","title":"R2: Defini\u00e7\u00e3o de Modelos de Dados","text":"<ul> <li><code>SecurityPattern</code> - Representa um padr\u00e3o de risco</li> <li><code>AuditResult</code> - Representa um achado de auditoria</li> <li>M\u00e9todo <code>to_dict()</code> para serializa\u00e7\u00e3o</li> </ul> <p>Problema: Modelos misturados com l\u00f3gica de an\u00e1lise.</p>"},{"location":"P12_CODE_AUDIT_REFACTORING_ANALYSIS/#r3-varredura-de-sistema-de-arquivos","title":"R3: Varredura de Sistema de Arquivos","text":"<ul> <li><code>_get_python_files()</code> - Descobre arquivos Python baseado em config</li> <li>L\u00f3gica de exclus\u00e3o de paths (linha 195-199)</li> <li>Suporte a glob patterns</li> </ul> <p>Problema: L\u00f3gica de descoberta acoplada ao CodeAuditor.</p>"},{"location":"P12_CODE_AUDIT_REFACTORING_ANALYSIS/#r4-analise-de-codigo-e-deteccao-de-padroes","title":"R4: An\u00e1lise de C\u00f3digo e Detec\u00e7\u00e3o de Padr\u00f5es","text":"<ul> <li><code>_analyze_file()</code> - Analisa arquivo individual</li> <li><code>_is_in_string_literal()</code> - Detecta falsos positivos</li> <li>Parsing de AST (linhas 222-227)</li> <li>Sistema de supress\u00e3o <code># noqa:</code> (linhas 233-242)</li> <li>Verifica\u00e7\u00e3o de regex patterns (linhas 229-242)</li> </ul> <p>Problema: An\u00e1lise est\u00e1tica complexa misturada com orquestra\u00e7\u00e3o.</p>"},{"location":"P12_CODE_AUDIT_REFACTORING_ANALYSIS/#r5-analise-de-cobertura-de-mocks","title":"R5: An\u00e1lise de Cobertura de Mocks","text":"<ul> <li><code>_check_mock_coverage()</code> - Analisa arquivos de teste</li> <li>Detecta uso de mocks vs chamadas externas</li> <li>Gera relat\u00f3rio de cobertura</li> </ul> <p>Problema: An\u00e1lise de testes acoplada ao auditor principal.</p>"},{"location":"P12_CODE_AUDIT_REFACTORING_ANALYSIS/#r6-simulacao-de-cicd","title":"R6: Simula\u00e7\u00e3o de CI/CD","text":"<ul> <li><code>_simulate_ci_environment()</code> - Executa pytest com flags CI</li> <li>Gest\u00e3o de timeouts e environment variables</li> <li>Captura de output/errors</li> </ul> <p>Problema: Responsabilidade de DevOps no mesmo m\u00f3dulo de an\u00e1lise est\u00e1tica.</p>"},{"location":"P12_CODE_AUDIT_REFACTORING_ANALYSIS/#r7-geracao-de-sugestoes","title":"R7: Gera\u00e7\u00e3o de Sugest\u00f5es","text":"<ul> <li><code>_generate_suggestion()</code> - Cria mensagens de corre\u00e7\u00e3o</li> <li><code>_generate_recommendations()</code> - Gera resumo executivo</li> <li>L\u00f3gica de mapeamento padr\u00e3o\u2192sugest\u00e3o</li> </ul> <p>Problema: L\u00f3gica de apresenta\u00e7\u00e3o misturada com an\u00e1lise.</p>"},{"location":"P12_CODE_AUDIT_REFACTORING_ANALYSIS/#r8-orquestracao-principal","title":"R8: Orquestra\u00e7\u00e3o Principal","text":"<ul> <li><code>run_audit()</code> - Coordena todas as etapas</li> <li>C\u00e1lculo de m\u00e9tricas de dura\u00e7\u00e3o</li> <li>Determina\u00e7\u00e3o de status geral (PASS/FAIL/WARNING/CRITICAL)</li> <li>Agrega\u00e7\u00e3o de resultados</li> </ul> <p>Problema: Fun\u00e7\u00e3o de 70+ linhas que faz \"tudo\".</p>"},{"location":"P12_CODE_AUDIT_REFACTORING_ANALYSIS/#r9-relatorios-e-persistencia","title":"R9: Relat\u00f3rios e Persist\u00eancia","text":"<ul> <li><code>save_report()</code> - Serializa para JSON/YAML</li> <li><code>print_summary()</code> - Output console formatado</li> <li>Formata\u00e7\u00e3o de emojis e cores</li> </ul> <p>Problema: M\u00faltiplos formatos de output no mesmo script.</p>"},{"location":"P12_CODE_AUDIT_REFACTORING_ANALYSIS/#r10-cli-e-parsing-de-argumentos","title":"R10: CLI e Parsing de Argumentos","text":"<ul> <li><code>main()</code> - Entry point com argparse</li> <li>Gest\u00e3o de flags (--config, --output, --quiet, --fail-on)</li> <li>Suporte a modo \"delta audit\" (pre-commit)</li> <li>Determina\u00e7\u00e3o de exit codes</li> </ul> <p>Problema: CLI acoplado \u00e0 l\u00f3gica de neg\u00f3cio.</p>"},{"location":"P12_CODE_AUDIT_REFACTORING_ANALYSIS/#13-dependencias-externas","title":"1.3 Depend\u00eancias Externas","text":"<pre><code># Standard Library (9 imports)\nargparse, ast, json, logging, os, re, subprocess, sys, datetime, pathlib\n\n# Third-Party (1 import)\nyaml\n</code></pre> <p>Observa\u00e7\u00e3o: Baixa depend\u00eancia externa, mas alto acoplamento interno.</p>"},{"location":"P12_CODE_AUDIT_REFACTORING_ANALYSIS/#14-pontos-de-dor-identificados","title":"1.4 Pontos de Dor Identificados","text":"# Problema Impacto Severidade 1 CodeAuditor com 15+ m\u00e9todos Dificulta compreens\u00e3o e manuten\u00e7\u00e3o \ud83d\udd34 ALTA 2 run_audit() com 70+ linhas Dificulta testes unit\u00e1rios \ud83d\udd34 ALTA 3 Mistura de I/O com l\u00f3gica Impossibilita testes isolados \ud83d\udfe0 M\u00c9DIA 4 Padr\u00f5es hardcoded em c\u00f3digo Inflex\u00edvel para extens\u00e3o \ud83d\udfe0 M\u00c9DIA 5 M\u00faltiplos formatadores (JSON/YAML/Console) Viola\u00e7\u00e3o de SRP \ud83d\udfe1 BAIXA 6 Simula\u00e7\u00e3o CI acoplada Deveria ser plug\u00e1vel \ud83d\udfe1 BAIXA"},{"location":"P12_CODE_AUDIT_REFACTORING_ANALYSIS/#parte-2-arquitetura-proposta","title":"\ud83c\udfd7\ufe0f PARTE 2: Arquitetura Proposta","text":""},{"location":"P12_CODE_AUDIT_REFACTORING_ANALYSIS/#21-visao-geral-da-nova-estrutura","title":"2.1 Vis\u00e3o Geral da Nova Estrutura","text":"<pre><code>scripts/audit/\n\u251c\u2500\u2500 __init__.py              # Exporta interfaces p\u00fablicas\n\u251c\u2500\u2500 models.py                # Data models (SecurityPattern, AuditResult, AuditReport)\n\u251c\u2500\u2500 config.py                # Configuration loading and validation\n\u251c\u2500\u2500 scanner.py               # File discovery and filtering\n\u251c\u2500\u2500 analyzer.py              # Pattern detection and code analysis\n\u251c\u2500\u2500 reporters/               # Output formatting\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 base.py             # AbstractReporter\n\u2502   \u251c\u2500\u2500 json_reporter.py    # JSON output\n\u2502   \u251c\u2500\u2500 yaml_reporter.py    # YAML output\n\u2502   \u2514\u2500\u2500 console_reporter.py # Terminal output\n\u251c\u2500\u2500 plugins/                 # Extensible analysis plugins\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 base.py             # AbstractPlugin\n\u2502   \u251c\u2500\u2500 mock_checker.py     # Mock coverage analysis\n\u2502   \u2514\u2500\u2500 ci_simulator.py     # CI/CD simulation\n\u251c\u2500\u2500 main.py                  # Orchestration logic\n\u2514\u2500\u2500 cli.py                   # CLI entry point (argparse)\n</code></pre>"},{"location":"P12_CODE_AUDIT_REFACTORING_ANALYSIS/#22-detalhamento-dos-modulos","title":"2.2 Detalhamento dos M\u00f3dulos","text":""},{"location":"P12_CODE_AUDIT_REFACTORING_ANALYSIS/#module-modelspy","title":"\ud83d\udce6 Module: <code>models.py</code>","text":"<p>Responsabilidade: Estruturas de dados imut\u00e1veis.</p> <pre><code># Conte\u00fado Proposto:\n- class SecurityPattern (dataclass)\n- class AuditResult (dataclass)\n- class AuditReport (dataclass com summary/findings/metadata)\n- class MockCoverageReport (dataclass)\n- class CISimulationResult (dataclass)\n</code></pre> <p>Benef\u00edcios:</p> <ul> <li>\u2705 Centraliza defini\u00e7\u00f5es de dados</li> <li>\u2705 Facilita serializa\u00e7\u00e3o/deserializa\u00e7\u00e3o</li> <li>\u2705 Valida tipos com type hints</li> <li>\u2705 Uso de <code>@dataclass</code> reduz boilerplate</li> </ul> <p>Migra\u00e7\u00e3o:</p> <ul> <li>Mover <code>SecurityPattern</code> (linhas 43-56)</li> <li>Mover <code>AuditResult</code> (linhas 59-87)</li> <li>Criar <code>AuditReport</code> para encapsular relat\u00f3rio final</li> </ul>"},{"location":"P12_CODE_AUDIT_REFACTORING_ANALYSIS/#module-configpy","title":"\u2699\ufe0f Module: <code>config.py</code>","text":"<p>Responsabilidade: Carregar e validar configura\u00e7\u00e3o.</p> <pre><code># Conte\u00fado Proposto:\n- class AuditConfig (dataclass)\n- def load_config(path: Path | None) -&gt; AuditConfig\n- def get_default_config() -&gt; dict[str, Any]\n</code></pre> <p>Benef\u00edcios:</p> <ul> <li>\u2705 Separa I/O de l\u00f3gica de neg\u00f3cio</li> <li>\u2705 Permite testes com configs mock</li> <li>\u2705 Valida\u00e7\u00e3o centralizada de YAML</li> </ul> <p>Migra\u00e7\u00e3o:</p> <ul> <li>Extrair <code>_load_config()</code> (linhas 106-129) \u2192 <code>load_config()</code></li> <li>Criar dataclass <code>AuditConfig</code> para type safety</li> </ul>"},{"location":"P12_CODE_AUDIT_REFACTORING_ANALYSIS/#module-scannerpy","title":"\ud83d\udd0d Module: <code>scanner.py</code>","text":"<p>Responsabilidade: Descoberta de arquivos Python.</p> <pre><code># Conte\u00fado Proposto:\n- class FileScanner:\n    - def scan_workspace(config: AuditConfig) -&gt; list[Path]\n    - def filter_excluded(files: list[Path]) -&gt; list[Path]\n    - def resolve_patterns(patterns: list[str]) -&gt; list[Path]\n</code></pre> <p>Benef\u00edcios:</p> <ul> <li>\u2705 L\u00f3gica de glob isolada</li> <li>\u2705 Test\u00e1vel com filesystem mock</li> <li>\u2705 Reutiliz\u00e1vel por outras ferramentas</li> </ul> <p>Migra\u00e7\u00e3o:</p> <ul> <li>Extrair <code>_get_python_files()</code> (linhas 170-192) \u2192 <code>FileScanner.scan_workspace()</code></li> </ul>"},{"location":"P12_CODE_AUDIT_REFACTORING_ANALYSIS/#module-analyzerpy","title":"\ud83e\uddea Module: <code>analyzer.py</code>","text":"<p>Responsabilidade: An\u00e1lise est\u00e1tica de c\u00f3digo Python.</p> <pre><code># Conte\u00fado Proposto:\n- class CodeAnalyzer:\n    - def __init__(patterns: list[SecurityPattern])\n    - def analyze_file(path: Path) -&gt; list[AuditResult]\n    - def _is_in_string_literal(line: str, pattern: str) -&gt; bool\n    - def _parse_noqa_suppressions(line: str) -&gt; list[str]\n    - def _generate_suggestion(pattern: SecurityPattern) -&gt; str\n</code></pre> <p>Benef\u00edcios:</p> <ul> <li>\u2705 Core logic isolado</li> <li>\u2705 F\u00e1cil adicionar novos tipos de an\u00e1lise</li> <li>\u2705 Test\u00e1vel com strings simples</li> </ul> <p>Migra\u00e7\u00e3o:</p> <ul> <li>Extrair <code>_analyze_file()</code> (linhas 194-288) \u2192 <code>CodeAnalyzer.analyze_file()</code></li> <li>Extrair <code>_is_in_string_literal()</code> (linhas 290-301)</li> <li>Extrair <code>_generate_suggestion()</code> (linhas 303-320)</li> </ul>"},{"location":"P12_CODE_AUDIT_REFACTORING_ANALYSIS/#module-reporters","title":"\ud83d\udcca Module: <code>reporters/</code>","text":"<p>Responsabilidade: Formata\u00e7\u00e3o de output.</p> <p>Estrutura:</p> <pre><code># base.py\n- class AbstractReporter (ABC):\n    - @abstractmethod def generate(report: AuditReport) -&gt; str\n\n# json_reporter.py\n- class JSONReporter(AbstractReporter)\n\n# yaml_reporter.py\n- class YAMLReporter(AbstractReporter)\n\n# console_reporter.py\n- class ConsoleReporter(AbstractReporter)\n    - Usa emojis e formata\u00e7\u00e3o ANSI\n</code></pre> <p>Benef\u00edcios:</p> <ul> <li>\u2705 Adicionar formatos (HTML, Markdown) sem tocar core</li> <li>\u2705 Strategy Pattern para flexibilidade</li> <li>\u2705 Cada reporter com testes espec\u00edficos</li> </ul> <p>Migra\u00e7\u00e3o:</p> <ul> <li>Extrair <code>save_report()</code> (linhas 419-433) \u2192 JSONReporter/YAMLReporter</li> <li>Extrair <code>print_summary()</code> (linhas 436-477) \u2192 ConsoleReporter</li> </ul>"},{"location":"P12_CODE_AUDIT_REFACTORING_ANALYSIS/#module-plugins","title":"\ud83d\udd0c Module: <code>plugins/</code>","text":"<p>Responsabilidade: An\u00e1lises opcionais e extens\u00edveis.</p> <p>Estrutura:</p> <pre><code># base.py\n- class AbstractPlugin (ABC):\n    - @abstractmethod def run(context: AuditContext) -&gt; dict[str, Any]\n\n# mock_checker.py\n- class MockCoveragePlugin(AbstractPlugin)\n\n# ci_simulator.py\n- class CISimulatorPlugin(AbstractPlugin)\n</code></pre> <p>Benef\u00edcios:</p> <ul> <li>\u2705 Plugins podem ser desabilitados por config</li> <li>\u2705 Terceiros podem adicionar plugins custom</li> <li>\u2705 Reduz complexidade do core</li> </ul> <p>Migra\u00e7\u00e3o:</p> <ul> <li>Extrair <code>_check_mock_coverage()</code> (linhas 322-374) \u2192 MockCoveragePlugin</li> <li>Extrair <code>_simulate_ci_environment()</code> (linhas 376-416) \u2192 CISimulatorPlugin</li> </ul>"},{"location":"P12_CODE_AUDIT_REFACTORING_ANALYSIS/#module-mainpy","title":"\ud83c\udfaf Module: <code>main.py</code>","text":"<p>Responsabilidade: Orquestra\u00e7\u00e3o (ex-<code>run_audit()</code>).</p> <pre><code># Conte\u00fado Proposto:\n- class AuditOrchestrator:\n    - def __init__(config, analyzer, scanner, plugins, reporters)\n    - def run(files: list[Path] | None) -&gt; AuditReport\n    - def _calculate_status(findings: list[AuditResult]) -&gt; str\n</code></pre> <p>Benef\u00edcios:</p> <ul> <li>\u2705 Dependency Injection para testabilidade</li> <li>\u2705 Coordena componentes sem conhecer detalhes</li> <li>\u2705 L\u00f3gica de neg\u00f3cio pura</li> </ul> <p>Migra\u00e7\u00e3o:</p> <ul> <li>Simplificar <code>run_audit()</code> (linhas 418-416) \u2192 <code>AuditOrchestrator.run()</code></li> <li>Extrair <code>_generate_recommendations()</code> (linhas 476-505)</li> </ul>"},{"location":"P12_CODE_AUDIT_REFACTORING_ANALYSIS/#module-clipy","title":"\ud83d\udda5\ufe0f Module: <code>cli.py</code>","text":"<p>Responsabilidade: Interface de linha de comando.</p> <pre><code># Conte\u00fado Proposto:\n- def create_parser() -&gt; argparse.ArgumentParser\n- def main() -&gt; None\n    - Parseia args\n    - Instancia componentes\n    - Chama AuditOrchestrator\n    - Determina exit code\n</code></pre> <p>Benef\u00edcios:</p> <ul> <li>\u2705 CLI desacoplado da l\u00f3gica de neg\u00f3cio</li> <li>\u2705 Facilita testes de integra\u00e7\u00e3o</li> <li>\u2705 Permite criar UIs alternativas (TUI, Web)</li> </ul> <p>Migra\u00e7\u00e3o:</p> <ul> <li>Extrair <code>main()</code> (linhas 480-564) \u2192 <code>cli.py</code></li> <li>Manter <code>__main__.py</code> apenas como entry point</li> </ul>"},{"location":"P12_CODE_AUDIT_REFACTORING_ANALYSIS/#23-diagrama-de-dependencias","title":"2.3 Diagrama de Depend\u00eancias","text":"<pre><code>cli.py\n  \u2193\nmain.AuditOrchestrator\n  \u251c\u2500\u2500\u2192 config.load_config()\n  \u251c\u2500\u2500\u2192 scanner.FileScanner\n  \u251c\u2500\u2500\u2192 analyzer.CodeAnalyzer\n  \u251c\u2500\u2500\u2192 plugins.MockCoveragePlugin\n  \u251c\u2500\u2500\u2192 plugins.CISimulatorPlugin\n  \u2514\u2500\u2500\u2192 reporters.JSONReporter\n          \u2191\n       models.py (usado por todos)\n</code></pre> <p>Fluxo de Execu\u00e7\u00e3o:</p> <ol> <li><code>cli.py</code> parseia argumentos</li> <li><code>config.py</code> carrega configura\u00e7\u00e3o</li> <li><code>scanner.py</code> descobre arquivos</li> <li><code>analyzer.py</code> analisa c\u00f3digo</li> <li><code>plugins/</code> executam an\u00e1lises opcionais</li> <li><code>main.py</code> agrega resultados em <code>AuditReport</code></li> <li><code>reporters/</code> geram output</li> <li><code>cli.py</code> determina exit code</li> </ol>"},{"location":"P12_CODE_AUDIT_REFACTORING_ANALYSIS/#24-beneficios-da-nova-arquitetura","title":"2.4 Benef\u00edcios da Nova Arquitetura","text":"Benef\u00edcio Antes Depois Testabilidade Dif\u00edcil (tudo acoplado) F\u00e1cil (m\u00f3dulos isolados) Extensibilidade Hardcoded patterns Plugin system Manutenibilidade 535 linhas em 1 arquivo ~80 linhas/m\u00f3dulo Reusabilidade Zero (tudo privado) Alta (m\u00f3dulos p\u00fablicos) Clareza Complexidade ciclom\u00e1tica &gt;15 &lt;5 por m\u00f3dulo"},{"location":"P12_CODE_AUDIT_REFACTORING_ANALYSIS/#25-compatibilidade-com-codigo-existente","title":"2.5 Compatibilidade com C\u00f3digo Existente","text":"<p>Garantias de Compatibilidade:</p> <pre><code># scripts/code_audit.py (mantido como wrapper legacy)\n\"\"\"\nDeprecated: This module is kept for backward compatibility.\nPlease use `python -m scripts.audit.cli` instead.\n\"\"\"\nfrom scripts.audit.cli import main\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>Migra\u00e7\u00e3o Gradual:</p> <ol> <li>\u2705 Fase 01: An\u00e1lise (atual)</li> <li>\ud83d\udd04 Fase 02: Criar novos m\u00f3dulos</li> <li>\ud83d\udd04 Fase 03: Migrar testes</li> <li>\ud83d\udd04 Fase 04: Deprecar code_audit.py</li> <li>\ud83d\udd04 Fase 05: Remover wrapper (ap\u00f3s 2 releases)</li> </ol>"},{"location":"P12_CODE_AUDIT_REFACTORING_ANALYSIS/#metricas-de-qualidade-esperadas","title":"\ud83d\udccf M\u00e9tricas de Qualidade Esperadas","text":""},{"location":"P12_CODE_AUDIT_REFACTORING_ANALYSIS/#antes-da-refatoracao","title":"Antes da Refatora\u00e7\u00e3o","text":"<pre><code>code_audit.py:\n  - Linhas: 535\n  - Complexidade Ciclom\u00e1tica: ~25\n  - Acoplamento: Alto\n  - Coes\u00e3o: Baixa\n  - Cobertura de Testes: ~40% (estimado)\n</code></pre>"},{"location":"P12_CODE_AUDIT_REFACTORING_ANALYSIS/#depois-da-refatoracao","title":"Depois da Refatora\u00e7\u00e3o","text":"<pre><code>scripts/audit/:\n  - M\u00f3dulos: 9 arquivos (~80 linhas cada)\n  - Complexidade Ciclom\u00e1tica: &lt;5 por m\u00f3dulo\n  - Acoplamento: Baixo (dependency injection)\n  - Coes\u00e3o: Alta (SRP)\n  - Cobertura de Testes: &gt;80% (target)\n</code></pre>"},{"location":"P12_CODE_AUDIT_REFACTORING_ANALYSIS/#proximos-passos-fase-02","title":"\ud83c\udfaf Pr\u00f3ximos Passos (Fase 02)","text":""},{"location":"P12_CODE_AUDIT_REFACTORING_ANALYSIS/#plano-de-implementacao","title":"Plano de Implementa\u00e7\u00e3o","text":"<p>Sprint 1: Funda\u00e7\u00f5es</p> <ul> <li>[ ] Criar <code>scripts/audit/__init__.py</code></li> <li>[ ] Implementar <code>models.py</code> com dataclasses</li> <li>[ ] Implementar <code>config.py</code> com valida\u00e7\u00e3o</li> </ul> <p>Sprint 2: Core Logic</p> <ul> <li>[ ] Implementar <code>scanner.py</code></li> <li>[ ] Implementar <code>analyzer.py</code></li> <li>[ ] Migrar testes unit\u00e1rios</li> </ul> <p>Sprint 3: Extens\u00f5es</p> <ul> <li>[ ] Implementar plugin system</li> <li>[ ] Migrar <code>mock_checker.py</code></li> <li>[ ] Migrar <code>ci_simulator.py</code></li> </ul> <p>Sprint 4: Output</p> <ul> <li>[ ] Implementar reporters</li> <li>[ ] Implementar <code>main.py</code> (orchestrator)</li> <li>[ ] Implementar <code>cli.py</code></li> </ul> <p>Sprint 5: Integra\u00e7\u00e3o</p> <ul> <li>[ ] Testes de integra\u00e7\u00e3o end-to-end</li> <li>[ ] Atualizar documenta\u00e7\u00e3o</li> <li>[ ] Criar wrapper de compatibilidade</li> </ul>"},{"location":"P12_CODE_AUDIT_REFACTORING_ANALYSIS/#validacao-da-arquitetura","title":"\ud83d\udd12 Valida\u00e7\u00e3o da Arquitetura","text":""},{"location":"P12_CODE_AUDIT_REFACTORING_ANALYSIS/#principios-solid-aplicados","title":"Princ\u00edpios SOLID Aplicados","text":"<p>\u2705 Single Responsibility Principle: Cada m\u00f3dulo tem UMA responsabilidade \u2705 Open/Closed Principle: Extens\u00edvel via plugins sem modificar core \u2705 Liskov Substitution: Reporters/Plugins intercambi\u00e1veis \u2705 Interface Segregation: Interfaces m\u00ednimas (AbstractReporter, AbstractPlugin) \u2705 Dependency Inversion: Orchestrator depende de abstra\u00e7\u00f5es, n\u00e3o implementa\u00e7\u00f5es</p>"},{"location":"P12_CODE_AUDIT_REFACTORING_ANALYSIS/#referencias","title":"\ud83d\udcda Refer\u00eancias","text":"<ul> <li>Livro: \"Refactoring: Improving the Design of Existing Code\" (Martin Fowler)</li> <li>Pattern: Strategy (reporters), Plugin (extens\u00f5es), Facade (orchestrator)</li> <li>Documenta\u00e7\u00e3o Interna:</li> <li><code>docs/CODE_AUDIT.md</code> - Documenta\u00e7\u00e3o atual do code_audit</li> <li><code>scripts/audit_config.yaml</code> - Configura\u00e7\u00e3o existente</li> </ul>"},{"location":"P12_CODE_AUDIT_REFACTORING_ANALYSIS/#conclusao","title":"\u2705 Conclus\u00e3o","text":"<p>O <code>code_audit.py</code> \u00e9 uma ferramenta robusta, mas sua arquitetura monol\u00edtica limita:</p> <ul> <li>\u274c Testabilidade</li> <li>\u274c Extensibilidade</li> <li>\u274c Manutenibilidade</li> </ul> <p>A arquitetura proposta resolve esses problemas atrav\u00e9s de:</p> <ul> <li>\u2705 Separa\u00e7\u00e3o de responsabilidades (SRP)</li> <li>\u2705 Inje\u00e7\u00e3o de depend\u00eancias</li> <li>\u2705 Sistema de plugins</li> <li>\u2705 M\u00f3dulos coesos e desacoplados</li> </ul> <p>Recomenda\u00e7\u00e3o: Prosseguir para Fase 02 (Implementa\u00e7\u00e3o) com a estrutura proposta.</p> <p>Documento Gerado por: GitHub Copilot Revis\u00e3o Necess\u00e1ria: Arquiteto de Software / Tech Lead Vers\u00e3o: 1.0.0 \u00daltima Atualiza\u00e7\u00e3o: 2025-11-19</p>"},{"location":"README_test_mock_system/","title":"Test Mock Generator System","text":"<p>Sistema robusto de gera\u00e7\u00e3o autom\u00e1tica de mocks para testes Python, seguindo padr\u00f5es DevOps e SRE.</p>"},{"location":"README_test_mock_system/#proposito","title":"\ud83c\udfaf Prop\u00f3sito","text":"<p>Este sistema automatiza a gera\u00e7\u00e3o e aplica\u00e7\u00e3o de mocks em arquivos de teste Python, garantindo que:</p> <ul> <li>Testes sejam est\u00e1veis no CI/CD (sem depend\u00eancias externas)</li> <li>C\u00f3digo seja port\u00e1vel entre diferentes ambientes</li> <li>Padr\u00f5es de qualidade sejam mantidos automaticamente</li> </ul>"},{"location":"README_test_mock_system/#arquitetura","title":"\ud83c\udfd7\ufe0f Arquitetura","text":"<pre><code>scripts/\n\u251c\u2500\u2500 test_mock_generator.py      # Gerador principal de mocks\n\u251c\u2500\u2500 test_mock_config.yaml       # Configura\u00e7\u00e3o extens\u00edvel\n\u251c\u2500\u2500 validate_test_mocks.py      # Validador do sistema\n\u251c\u2500\u2500 ci_test_mock_integration.py # Integra\u00e7\u00e3o CI/CD\n\u2514\u2500\u2500 README_test_mock_system.md  # Este arquivo\n</code></pre>"},{"location":"README_test_mock_system/#uso-rapido","title":"\ud83d\ude80 Uso R\u00e1pido","text":""},{"location":"README_test_mock_system/#1-escanear-arquivos-de-teste","title":"1. Escanear Arquivos de Teste","text":"<pre><code>python3 scripts/test_mock_generator.py --scan\n</code></pre>"},{"location":"README_test_mock_system/#2-preview-das-correcoes","title":"2. Preview das Corre\u00e7\u00f5es","text":"<pre><code>python3 scripts/test_mock_generator.py --apply --dry-run\n</code></pre>"},{"location":"README_test_mock_system/#3-aplicar-correcoes","title":"3. Aplicar Corre\u00e7\u00f5es","text":"<pre><code>python3 scripts/test_mock_generator.py --apply\n</code></pre>"},{"location":"README_test_mock_system/#4-validar-sistema","title":"4. Validar Sistema","text":"<pre><code>python3 scripts/validate_test_mocks.py --fix-found-issues\n</code></pre>"},{"location":"README_test_mock_system/#funcionalidades","title":"\ud83d\udccb Funcionalidades","text":""},{"location":"README_test_mock_system/#deteccao-automatica","title":"\u2705 Detec\u00e7\u00e3o Autom\u00e1tica","text":"<ul> <li>Requisi\u00e7\u00f5es HTTP (<code>httpx.get</code>, <code>requests.post</code>, etc.)</li> <li>Execu\u00e7\u00e3o de subprocessos (<code>subprocess.run</code>, <code>Popen</code>)</li> <li>Opera\u00e7\u00f5es de arquivo (<code>open()</code>, <code>pathlib.Path</code>)</li> <li>Conex\u00f5es de banco (<code>sqlite3.connect</code>)</li> </ul>"},{"location":"README_test_mock_system/#seguranca-robustez","title":"\ud83d\udee1\ufe0f Seguran\u00e7a &amp; Robustez","text":"<ul> <li>Backup autom\u00e1tico antes de modificar arquivos</li> <li>Idempot\u00eancia - pode ser executado m\u00faltiplas vezes</li> <li>Logging estruturado para auditoria</li> <li>Valida\u00e7\u00e3o de sintaxe antes e depois</li> </ul>"},{"location":"README_test_mock_system/#configurabilidade","title":"\ud83d\udd27 Configurabilidade","text":"<ul> <li>Padr\u00f5es extens\u00edveis via YAML</li> <li>Templates personaliz\u00e1veis de mock</li> <li>Severidade configur\u00e1vel (HIGH, MEDIUM, LOW)</li> <li>Filtros por tipo de projeto</li> </ul>"},{"location":"README_test_mock_system/#integracao-cicd","title":"\ud83c\udfed Integra\u00e7\u00e3o CI/CD","text":""},{"location":"README_test_mock_system/#github-actions","title":"GitHub Actions","text":"<pre><code>- name: Check Test Mocks\n  run: python3 scripts/ci_test_mock_integration.py --check --fail-on-issues\n\n- name: Auto-fix Test Issues\n  run: python3 scripts/ci_test_mock_integration.py --auto-fix --commit\n</code></pre>"},{"location":"README_test_mock_system/#gitlab-ci","title":"GitLab CI","text":"<pre><code>test_mock_check:\n  script:\n    - python3 scripts/ci_test_mock_integration.py --check --fail-on-issues\n  allow_failure: false\n</code></pre>"},{"location":"README_test_mock_system/#relatorios","title":"\ud83d\udcca Relat\u00f3rios","text":"<p>O sistema gera relat\u00f3rios detalhados em JSON:</p> <pre><code>{\n  \"timestamp\": \"2025-10-31T18:00:00Z\",\n  \"summary\": {\n    \"total_suggestions\": 15,\n    \"high_priority\": 8,\n    \"files_analyzed\": 25\n  },\n  \"suggestions\": [\n    {\n      \"file\": \"tests/test_api.py\",\n      \"function\": \"test_get_user\",\n      \"line\": 45,\n      \"pattern\": \"httpx.get(\",\n      \"severity\": \"HIGH\",\n      \"description\": \"HTTP GET request - needs mocking for CI stability\"\n    }\n  ]\n}\n</code></pre>"},{"location":"README_test_mock_system/#configuracao","title":"\ud83c\udf9b\ufe0f Configura\u00e7\u00e3o","text":""},{"location":"README_test_mock_system/#arquivo-test_mock_configyaml","title":"Arquivo <code>test_mock_config.yaml</code>","text":"<pre><code># Padr\u00f5es customiz\u00e1veis\nmock_patterns:\n  http_patterns:\n    - pattern: \"httpx.get(\"\n      severity: \"HIGH\"\n      mock_template: |\n        @patch(\"httpx.get\")\n        def {func_name}(self, mock_get, *args, **kwargs):\n            mock_response = Mock()\n            mock_response.status_code = 200\n            mock_get.return_value = mock_response\n\n# Configura\u00e7\u00f5es de execu\u00e7\u00e3o\nexecution:\n  min_severity_for_auto_apply: \"HIGH\"\n  create_backups: true\n  backup_directory: \".test_mock_backups\"\n</code></pre>"},{"location":"README_test_mock_system/#padroes-de-qualidade","title":"\ud83c\udfc6 Padr\u00f5es de Qualidade","text":""},{"location":"README_test_mock_system/#compatibilidade","title":"Compatibilidade","text":"<ul> <li>Python 3.10+</li> <li>POSIX-compliant (Linux, macOS, WSL)</li> <li>Portabilidade entre ambientes CI/CD</li> </ul>"},{"location":"README_test_mock_system/#seguranca","title":"Seguran\u00e7a","text":"<ul> <li>\u2705 Sem uso de <code>shell=True</code></li> <li>\u2705 Valida\u00e7\u00e3o de caminhos de arquivo</li> <li>\u2705 Tratamento seguro de exceptions</li> <li>\u2705 Logging de auditoria</li> </ul>"},{"location":"README_test_mock_system/#performance","title":"Performance","text":"<ul> <li>\u2705 Processamento em lote</li> <li>\u2705 Cache de an\u00e1lise AST</li> <li>\u2705 Opera\u00e7\u00f5es idempotentes</li> </ul>"},{"location":"README_test_mock_system/#manutenibilidade","title":"Manutenibilidade","text":"<ul> <li>\u2705 Type hints completos</li> <li>\u2705 Documenta\u00e7\u00e3o inline</li> <li>\u2705 Testes automatizados</li> <li>\u2705 Configura\u00e7\u00e3o declarativa</li> </ul>"},{"location":"README_test_mock_system/#extensibilidade","title":"\ud83d\udd27 Extensibilidade","text":""},{"location":"README_test_mock_system/#adicionando-novos-padroes","title":"Adicionando Novos Padr\u00f5es","text":"<ol> <li>Edite <code>test_mock_config.yaml</code>:</li> </ol> <pre><code>custom_patterns:\n  - pattern: \"my_library.connect(\"\n    type: \"CUSTOM_SERVICE\"\n    severity: \"HIGH\"\n    mock_template: |\n      @patch(\"my_library.connect\")\n      def {func_name}(self, mock_connect, *args, **kwargs):\n          mock_connect.return_value = Mock()\n</code></pre> <ol> <li>O sistema detectar\u00e1 automaticamente novos padr\u00f5es</li> </ol>"},{"location":"README_test_mock_system/#integrando-com-ferramentas","title":"Integrando com Ferramentas","text":"<pre><code>from test_mock_generator import TestMockGenerator\nfrom pathlib import Path\n\n# Uso program\u00e1tico\nworkspace = Path.cwd()\nconfig_path = Path(__file__).parent / \"test_mock_config.yaml\"\ngenerator = TestMockGenerator(workspace, config_path) # &lt;-- CORRIGIDO\n\nreport = generator.scan_test_files()\ngenerator.apply_suggestions(dry_run=False)\n</code></pre>"},{"location":"README_test_mock_system/#metricas-e-monitoramento","title":"\ud83d\udcc8 M\u00e9tricas e Monitoramento","text":""},{"location":"README_test_mock_system/#codigos-de-saida","title":"C\u00f3digos de Sa\u00edda","text":"<ul> <li><code>0</code> - Sucesso completo</li> <li><code>1</code> - Warning (problemas menores)</li> <li><code>2</code> - Failure (problemas cr\u00edticos)</li> </ul>"},{"location":"README_test_mock_system/#logs-estruturados","title":"Logs Estruturados","text":"<pre><code>2025-10-31 18:00:00 [INFO] test_mock_generator: Escaneamento conclu\u00eddo: 15 sugest\u00f5es geradas\n2025-10-31 18:00:05 [INFO] test_mock_generator: Mock aplicado: test_api.py:test_get_user\n</code></pre>"},{"location":"README_test_mock_system/#resolucao-de-problemas","title":"\ud83d\udee0\ufe0f Resolu\u00e7\u00e3o de Problemas","text":""},{"location":"README_test_mock_system/#problema-nenhuma-sugestao-encontrada","title":"Problema: \"Nenhuma sugest\u00e3o encontrada\"","text":"<pre><code># Criar arquivos de teste de exemplo\npython3 scripts/validate_test_mocks.py --fix-found-issues\n</code></pre>"},{"location":"README_test_mock_system/#problema-erro-de-sintaxe-apos-aplicacao","title":"Problema: \"Erro de sintaxe ap\u00f3s aplica\u00e7\u00e3o\"","text":"<pre><code># Recomenda-se executar os testes para validar as corre\u00e7\u00f5es:\npython3 -m pytest tests/\n</code></pre>"},{"location":"README_test_mock_system/#problema-git-commit-falhou","title":"Problema: \"Git commit falhou\"","text":"<pre><code># Verificar status\ngit status\ngit diff\n\n# Commit manual se necess\u00e1rio\ngit add .\ngit commit -m \"fix(tests): Apply test mocks\"\n</code></pre>"},{"location":"README_test_mock_system/#casos-de-uso","title":"\ud83c\udfaf Casos de Uso","text":""},{"location":"README_test_mock_system/#1-projeto-cli","title":"1. Projeto CLI","text":"<ul> <li>Foco em mocks de <code>subprocess</code> e <code>sys.argv</code></li> <li>Valida\u00e7\u00e3o de entrada/sa\u00edda</li> </ul>"},{"location":"README_test_mock_system/#2-projeto-api","title":"2. Projeto API","text":"<ul> <li>Mocks de requisi\u00e7\u00f5es HTTP</li> <li>Mocks de banco de dados</li> <li>Valida\u00e7\u00e3o de endpoints</li> </ul>"},{"location":"README_test_mock_system/#3-projeto-library","title":"3. Projeto Library","text":"<ul> <li>Mocks minimais</li> <li>Foco na l\u00f3gica de neg\u00f3cio</li> <li>Testes de integra\u00e7\u00e3o opcional</li> </ul>"},{"location":"README_test_mock_system/#referencias","title":"\ud83d\udcda Refer\u00eancias","text":"<ul> <li>PEP 8 - Style Guide</li> <li>unittest.mock Documentation</li> <li>pytest Best Practices</li> <li>DevOps Automation Patterns</li> </ul>"},{"location":"README_test_mock_system/#contribuicao","title":"\ud83e\udd1d Contribui\u00e7\u00e3o","text":"<p>Este sistema faz parte do Python Template Profissional e segue os padr\u00f5es:</p> <ul> <li>Idempot\u00eancia obrigat\u00f3ria</li> <li>Logging estruturado</li> <li>Configura\u00e7\u00e3o declarativa</li> <li>Testes automatizados</li> <li>Documenta\u00e7\u00e3o completa</li> </ul> <p>Autor: DevOps Template Generator Vers\u00e3o: 1.0.0 Licen\u00e7a: MIT Compatibilidade: Python 3.10+, POSIX</p>"},{"location":"SMART_GIT_SYNC_GUIDE/","title":"Smart Git Sync - Documenta\u00e7\u00e3o de Uso","text":""},{"location":"SMART_GIT_SYNC_GUIDE/#visao-geral","title":"Vis\u00e3o Geral","text":"<p>O Smart Git Sync \u00e9 um sistema de sincroniza\u00e7\u00e3o inteligente de Git que integra auditoria preventiva, corre\u00e7\u00f5es autom\u00e1ticas e opera\u00e7\u00f5es Git seguras. Foi desenvolvido seguindo padr\u00f5es DevOps/SRE para ser idempotente, seguro e robusto.</p>"},{"location":"SMART_GIT_SYNC_GUIDE/#caracteristicas-principais","title":"Caracter\u00edsticas Principais","text":""},{"location":"SMART_GIT_SYNC_GUIDE/#padroes-devops-implementados","title":"\u2705 Padr\u00f5es DevOps Implementados","text":"<ul> <li>Idempot\u00eancia: Pode ser executado m\u00faltiplas vezes sem efeitos colaterais</li> <li>POSIX Compliance: Scripts compat\u00edveis com diferentes sistemas Unix/Linux</li> <li>Seguran\u00e7a: Nunca usa <code>shell=True</code>, valida todas as entradas</li> <li>Type Safety: C\u00f3digo completamente tipado com Python 3.10+</li> <li>Structured Logging: Sistema de logging profissional com n\u00edveis</li> <li>Rollback Capability: Desfaz opera\u00e7\u00f5es em caso de falha</li> <li>Configurabilidade: Totalmente configur\u00e1vel via YAML</li> </ul>"},{"location":"SMART_GIT_SYNC_GUIDE/#recursos-de-seguranca","title":"\ud83d\udee1\ufe0f Recursos de Seguran\u00e7a","text":"<ul> <li>Valida\u00e7\u00e3o de entrada rigorosa</li> <li>Execu\u00e7\u00e3o de subprocess segura (sem <code>shell=True</code>)</li> <li>Rollback autom\u00e1tico em falhas de push</li> <li>Auditoria preventiva de c\u00f3digo</li> <li>Exclus\u00e3o autom\u00e1tica de arquivos sens\u00edveis</li> </ul>"},{"location":"SMART_GIT_SYNC_GUIDE/#auditoria-preventiva","title":"\ud83d\udd0d Auditoria Preventiva","text":"<ul> <li>An\u00e1lise de seguran\u00e7a est\u00e1tica</li> <li>Detec\u00e7\u00e3o de depend\u00eancias externas</li> <li>Simula\u00e7\u00e3o de ambiente CI/CD</li> <li>Corre\u00e7\u00f5es autom\u00e1ticas de lint</li> <li>Relat\u00f3rios estruturados</li> </ul>"},{"location":"SMART_GIT_SYNC_GUIDE/#instalacao","title":"Instala\u00e7\u00e3o","text":""},{"location":"SMART_GIT_SYNC_GUIDE/#pre-requisitos","title":"Pr\u00e9-requisitos","text":"<pre><code># Python 3.10+ required\npython3 --version\n\n# Instalar depend\u00eancias (incluindo PyYAML e tomli)\npip install .[dev]\n</code></pre>"},{"location":"SMART_GIT_SYNC_GUIDE/#estrutura-de-arquivos","title":"Estrutura de Arquivos","text":"<pre><code>scripts/\n\u251c\u2500\u2500 smart_git_sync.py              # Script principal\n\u251c\u2500\u2500 smart_git_sync_config.yaml     # Configura\u00e7\u00e3o\n\u251c\u2500\u2500 test_smart_git_sync.py         # Testes\n\u2514\u2500\u2500 code_audit.py                  # Sistema de auditoria (existente)\n</code></pre>"},{"location":"SMART_GIT_SYNC_GUIDE/#uso-basico","title":"Uso B\u00e1sico","text":""},{"location":"SMART_GIT_SYNC_GUIDE/#1-execucao-simples","title":"1. Execu\u00e7\u00e3o Simples","text":"<pre><code># Sincroniza\u00e7\u00e3o completa com auditoria\npython3 scripts/smart_git_sync.py\n\n# Modo dry-run (apenas simula)\npython3 scripts/smart_git_sync.py --dry-run\n\n# Com configura\u00e7\u00e3o personalizada\npython3 scripts/smart_git_sync.py --config custom_config.yaml\n</code></pre>"},{"location":"SMART_GIT_SYNC_GUIDE/#2-configuracao-personalizada","title":"2. Configura\u00e7\u00e3o Personalizada","text":"<p>Crie um arquivo <code>custom_config.yaml</code>:</p> <pre><code># Configura\u00e7\u00e3o customizada\naudit_enabled: true\naudit_fail_threshold: \"MEDIUM\"\nauto_fix_enabled: true\nstrict_audit: false\ncleanup_enabled: true\n\n# Timeouts\naudit_timeout: 180\ngit_timeout: 60\nlint_timeout: 120\n\n# Seguran\u00e7a\nexcluded_paths:\n  - \".env\"\n  - \"*.log\"\n  - \"__pycache__/\"\n\nallowed_file_extensions:\n  - \".py\"\n  - \".yaml\"\n  - \".md\"\n</code></pre>"},{"location":"SMART_GIT_SYNC_GUIDE/#3-integracao-com-cicd","title":"3. Integra\u00e7\u00e3o com CI/CD","text":""},{"location":"SMART_GIT_SYNC_GUIDE/#github-actions","title":"GitHub Actions","text":"<pre><code>name: Smart Sync\non: [push, pull_request]\n\njobs:\n  smart-sync:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Setup Python\n        uses: actions/setup-python@v4\n        with:\n          python-version: '3.10'\n\n      - name: Install Dependencies\n        run: |\n          python3 -m pip install --upgrade pip\n          pip install .[dev]\n\n      - name: Run Smart Git Sync (Dry Run)\n        run: python3 scripts/smart_git_sync.py --dry-run --verbose\n</code></pre>"},{"location":"SMART_GIT_SYNC_GUIDE/#funcionalidades-avancadas","title":"Funcionalidades Avan\u00e7adas","text":""},{"location":"SMART_GIT_SYNC_GUIDE/#1-workflow-completo","title":"1. Workflow Completo","text":"<p>O Smart Git Sync executa as seguintes fases:</p> <pre><code>\ud83d\udccb FASE 1: An\u00e1lise do Status do Reposit\u00f3rio\n\u251c\u2500\u2500 Verifica mudan\u00e7as pendentes\n\u251c\u2500\u2500 Identifica branch atual\n\u2514\u2500\u2500 Valida estado do reposit\u00f3rio\n\n\ud83d\udd0d FASE 2: Auditoria Preventiva de C\u00f3digo\n\u251c\u2500\u2500 Executa an\u00e1lise de seguran\u00e7a\n\u251c\u2500\u2500 Simula ambiente CI/CD\n\u251c\u2500\u2500 Detecta vulnerabilidades\n\u2514\u2500\u2500 Gera relat\u00f3rio de auditoria\n\n\ud83d\udd27 FASE 3: Corre\u00e7\u00f5es Autom\u00e1ticas (se necess\u00e1rio)\n\u251c\u2500\u2500 Aplica fixes de lint\n\u251c\u2500\u2500 Corrige imports\n\u251c\u2500\u2500 Formata c\u00f3digo\n\u2514\u2500\u2500 Remove c\u00f3digo n\u00e3o utilizado\n\n\ud83d\udce4 FASE 4: Opera\u00e7\u00f5es Git\n\u251c\u2500\u2500 Adiciona arquivos ao stage\n\u251c\u2500\u2500 Cria commit inteligente\n\u251c\u2500\u2500 Faz push para remote\n\u2514\u2500\u2500 Rollback em caso de falha\n\n\ud83e\uddf9 FASE 5: Limpeza do Reposit\u00f3rio\n\u251c\u2500\u2500 Git garbage collection\n\u251c\u2500\u2500 Remote prune\n\u2514\u2500\u2500 Otimiza\u00e7\u00f5es de performance\n</code></pre>"},{"location":"SMART_GIT_SYNC_GUIDE/#2-mensagens-de-commit-inteligentes","title":"2. Mensagens de Commit Inteligentes","text":"<p>O sistema analisa as mudan\u00e7as e gera mensagens seguindo conven\u00e7\u00f5es:</p> <pre><code>feat: smart sync with preventive audit (5 files) [audit-fixes]\nfix: smart sync with preventive audit (2 files)\ndocs: smart sync with preventive audit (3 files)\ntest: smart sync with preventive audit (1 files)\nchore: smart sync with preventive audit (4 files)\n</code></pre>"},{"location":"SMART_GIT_SYNC_GUIDE/#3-relatorios-estruturados","title":"3. Relat\u00f3rios Estruturados","text":"<p>Cada execu\u00e7\u00e3o gera um relat\u00f3rio JSON completo:</p> <pre><code>{\n  \"metadata\": {\n    \"sync_id\": \"20231102_143022\",\n    \"timestamp\": \"2023-11-02T14:30:22.123456Z\",\n    \"workspace\": \"/path/to/project\",\n    \"dry_run\": false\n  },\n  \"steps\": [\n    {\n      \"name\": \"git_status\",\n      \"status\": \"success\",\n      \"duration_seconds\": 0.125,\n      \"details\": {\n        \"is_clean\": false,\n        \"total_changes\": 3,\n        \"current_branch\": \"main\"\n      }\n    }\n  ],\n  \"summary\": {\n    \"total_steps\": 5,\n    \"successful_steps\": 5,\n    \"failed_steps\": 0,\n    \"total_duration\": 12.45\n  }\n}\n</code></pre>"},{"location":"SMART_GIT_SYNC_GUIDE/#tratamento-de-erros","title":"Tratamento de Erros","text":""},{"location":"SMART_GIT_SYNC_GUIDE/#1-rollback-automatico","title":"1. Rollback Autom\u00e1tico","text":"<pre><code># Se o push falhar, o sistema automaticamente:\ntry:\n    git_push()\nexcept GitOperationError:\n    # Rollback do commit\n    git reset --soft HEAD~1\n    # Log do erro\n    # Preserva mudan\u00e7as locais\n</code></pre>"},{"location":"SMART_GIT_SYNC_GUIDE/#2-tipos-de-erro","title":"2. Tipos de Erro","text":"<ul> <li>SyncError: Erro geral de sincroniza\u00e7\u00e3o</li> <li>GitOperationError: Falha em opera\u00e7\u00e3o Git</li> <li>AuditError: Falha na auditoria de c\u00f3digo</li> </ul>"},{"location":"SMART_GIT_SYNC_GUIDE/#3-recuperacao-graceful","title":"3. Recupera\u00e7\u00e3o Graceful","text":"<pre><code># O sistema preserva estado em caso de falha\n# Relat\u00f3rios s\u00e3o sempre salvos\n# Logs detalhados para debugging\n# Opera\u00e7\u00f5es s\u00e3o at\u00f4micas quando poss\u00edvel\n</code></pre>"},{"location":"SMART_GIT_SYNC_GUIDE/#testes","title":"Testes","text":""},{"location":"SMART_GIT_SYNC_GUIDE/#1-executar-testes","title":"1. Executar Testes","text":"<pre><code># Testes completos\npython3 scripts/test_smart_git_sync.py\n\n# Apenas testes unit\u00e1rios\npython3 scripts/test_smart_git_sync.py --unit-tests-only\n\n# Modo verbose\npython3 scripts/test_smart_git_sync.py --verbose\n</code></pre>"},{"location":"SMART_GIT_SYNC_GUIDE/#2-validacao-de-seguranca","title":"2. Valida\u00e7\u00e3o de Seguran\u00e7a","text":"<pre><code># O sistema de testes inclui:\n# - Verifica\u00e7\u00e3o de padr\u00f5es inseguros\n# - Valida\u00e7\u00e3o de configura\u00e7\u00e3o\n# - Testes de integra\u00e7\u00e3o\n# - An\u00e1lise de cobertura de c\u00f3digo\n</code></pre>"},{"location":"SMART_GIT_SYNC_GUIDE/#configuracao-avancada","title":"Configura\u00e7\u00e3o Avan\u00e7ada","text":""},{"location":"SMART_GIT_SYNC_GUIDE/#1-configuracao-completa","title":"1. Configura\u00e7\u00e3o Completa","text":"<pre><code># smart_git_sync_config.yaml\n\n# Auditoria\naudit_enabled: true\naudit_timeout: 300\naudit_fail_threshold: \"HIGH\"  # CRITICAL, HIGH, MEDIUM, LOW\nstrict_audit: true\n\n# Corre\u00e7\u00f5es autom\u00e1ticas\nauto_fix_enabled: true\nlint_timeout: 180\n\n# Git\ngit_timeout: 120\ncleanup_enabled: true\n\n# Seguran\u00e7a\nallowed_file_extensions:\n  - \".py\"\n  - \".yaml\"\n  - \".json\"\n  - \".md\"\n\nexcluded_paths:\n  - \".git/\"\n  - \"__pycache__/\"\n  - \".env\"\n  - \"*.log\"\n\n# CI/CD\nsimulate_ci: true\nci_timeout: 300\n\n# Performance\nmax_files_per_commit: 100\nmax_commit_message_length: 72\n\n# Logging\nlog_level: \"INFO\"\nlog_to_file: true\nlog_file: \"smart_git_sync.log\"\n</code></pre>"},{"location":"SMART_GIT_SYNC_GUIDE/#2-integracao-com-hooks","title":"2. Integra\u00e7\u00e3o com Hooks","text":"<pre><code># .git/hooks/pre-commit\n#!/bin/bash\npython3 scripts/smart_git_sync.py --dry-run\n</code></pre>"},{"location":"SMART_GIT_SYNC_GUIDE/#solucao-de-problemas","title":"Solu\u00e7\u00e3o de Problemas","text":""},{"location":"SMART_GIT_SYNC_GUIDE/#1-problemas-comuns","title":"1. Problemas Comuns","text":"<p>Erro: \"Not a Git repository\"</p> <pre><code># Certifique-se de estar em um reposit\u00f3rio Git\ngit init\n</code></pre> <p>Erro: \"Code audit failed\"</p> <pre><code># Execute auditoria manualmente para debug\npython3 scripts/code_audit.py --verbose\n</code></pre> <p>Erro: \"Push failed\"</p> <pre><code># Verifique conectividade e permiss\u00f5es\ngit remote -v\ngit push origin main\n</code></pre>"},{"location":"SMART_GIT_SYNC_GUIDE/#2-debug-mode","title":"2. Debug Mode","text":"<pre><code># Ativar debug completo\npython3 scripts/smart_git_sync.py --verbose\n\n# Verificar logs\ntail -f smart_git_sync.log\n</code></pre>"},{"location":"SMART_GIT_SYNC_GUIDE/#3-modo-de-recuperacao","title":"3. Modo de Recupera\u00e7\u00e3o","text":"<pre><code># Se algo der errado, use dry-run primeiro\npython3 scripts/smart_git_sync.py --dry-run --verbose\n\n# Desabilite auditoria temporariamente\npython3 scripts/smart_git_sync.py --no-audit\n</code></pre>"},{"location":"SMART_GIT_SYNC_GUIDE/#boas-praticas","title":"Boas Pr\u00e1ticas","text":""},{"location":"SMART_GIT_SYNC_GUIDE/#1-uso-em-producao","title":"1. Uso em Produ\u00e7\u00e3o","text":"<ul> <li>Sempre teste com <code>--dry-run</code> primeiro</li> <li>Configure timeouts apropriados</li> <li>Use auditoria estrita em produ\u00e7\u00e3o</li> <li>Monitore logs regularmente</li> <li>Mantenha backups de configura\u00e7\u00e3o</li> </ul>"},{"location":"SMART_GIT_SYNC_GUIDE/#2-desenvolvimento","title":"2. Desenvolvimento","text":"<ul> <li>Use modo verbose durante desenvolvimento</li> <li>Execute testes antes de commits</li> <li>Revise relat\u00f3rios de auditoria</li> <li>Configure exclus\u00f5es apropriadas</li> <li>Documente configura\u00e7\u00f5es customizadas</li> </ul>"},{"location":"SMART_GIT_SYNC_GUIDE/#3-cicd-integration","title":"3. CI/CD Integration","text":"<ul> <li>Execute sempre em modo dry-run no CI</li> <li>Use configura\u00e7\u00f5es espec\u00edficas por ambiente</li> <li>Monitore m\u00e9tricas de performance</li> <li>Configure alertas para falhas</li> <li>Mantenha logs centralizados</li> </ul>"},{"location":"SMART_GIT_SYNC_GUIDE/#roadmap","title":"Roadmap","text":""},{"location":"SMART_GIT_SYNC_GUIDE/#funcionalidades-futuras","title":"Funcionalidades Futuras","text":"<ul> <li>[ ] Integra\u00e7\u00e3o com ferramentas de qualidade (SonarQube, CodeClimate)</li> <li>[ ] Suporte a m\u00faltiplos reposit\u00f3rios</li> <li>[ ] Dashboard web para m\u00e9tricas</li> <li>[ ] Integra\u00e7\u00e3o com sistemas de tickets</li> <li>[ ] Suporte a Git LFS</li> <li>[ ] Notifica\u00e7\u00f5es via Slack/Teams</li> <li>[ ] An\u00e1lise de performance de c\u00f3digo</li> <li>[ ] Integra\u00e7\u00e3o com ferramentas de seguran\u00e7a (Snyk, etc.)</li> </ul>"},{"location":"SMART_GIT_SYNC_GUIDE/#conclusao","title":"Conclus\u00e3o","text":"<p>O Smart Git Sync fornece uma solu\u00e7\u00e3o robusta e segura para automa\u00e7\u00e3o de Git que pode ser usada em qualquer projeto Python. Seguindo padr\u00f5es DevOps, ele garante opera\u00e7\u00f5es idempotentes, seguras e audit\u00e1veis.</p> <p>Para suporte ou contribui\u00e7\u00f5es, consulte a documenta\u00e7\u00e3o do projeto ou abra uma issue no reposit\u00f3rio.</p>"},{"location":"guides/testing/","title":"\ud83e\uddea Guia de Testes (SRE Standard)","text":"<p>Este projeto adota uma filosofia estrita de Testes Unit\u00e1rios Isolados. O objetivo \u00e9 garantir que a su\u00edte de testes seja r\u00e1pida (&lt; 50ms), determin\u00edstica e segura (sem efeitos colaterais).</p>"},{"location":"guides/testing/#o-que-nao-fazer-anti-patterns","title":"\ud83d\udeab O Que N\u00e3o Fazer (Anti-Patterns)","text":"<ol> <li>Nunca toque no disco real: N\u00e3o use <code>os.mkdir</code>, <code>open(\"arquivo_real\")</code> ou <code>tempfile.mkdtemp</code>.</li> <li>Nunca execute comandos reais: N\u00e3o chame <code>subprocess.run([\"git\", ...])</code> sem mock.</li> <li>Nunca dependa de estado externo: N\u00e3o assuma que o usu\u00e1rio tem Git instalado ou configurado.</li> </ol>"},{"location":"guides/testing/#como-escrever-testes-the-right-way","title":"\u2705 Como Escrever Testes (The Right Way)","text":"<p>Usamos <code>unittest.mock</code> intensivamente.</p>"},{"location":"guides/testing/#exemplo-mockando-arquivos-e-comandos","title":"Exemplo: Mockando Arquivos e Comandos","text":"<pre><code>from unittest.mock import MagicMock, patch\nfrom pathlib import Path\n\n# 1. Patch no subprocess (Blindagem)\n@patch(\"scripts.git_sync.sync_logic.subprocess.run\")\n# 2. Patch no Path (Filesystem Virtual)\n@patch(\"scripts.git_sync.sync_logic.Path\")\ndef test_exemplo_seguro(self, mock_path, mock_run):\n\n    # Configurar o Mock do Filesystem\n    mock_path.return_value.exists.return_value = True\n\n    # Configurar o Mock do Comando\n    mock_run.return_value.returncode = 0\n\n    # Executar (O c\u00f3digo acha que est\u00e1 tocando no disco, mas n\u00e3o est\u00e1)\n    resultado = minha_funcao_perigosa()\n\n    # Validar\n    assert resultado == True\n</code></pre> <p>Consulte <code>tests/test_smart_git_sync.py</code> para exemplos avan\u00e7ados de mocks em cadeia.</p>"},{"location":"reference/git_sync/","title":"Git Sync - Refer\u00eancia da API","text":"<p>Sincroniza\u00e7\u00e3o Git inteligente com sistema de auditoria preventiva</p>"},{"location":"reference/git_sync/#visao-geral","title":"Vis\u00e3o Geral","text":"<p>O m\u00f3dulo <code>scripts.git_sync</code> fornece funcionalidades empresariais para sincroniza\u00e7\u00e3o Git automatizada com capacidades de auditoria preventiva.</p>"},{"location":"reference/git_sync/#classes-principais","title":"Classes Principais","text":""},{"location":"reference/git_sync/#scripts.git_sync.sync_logic.SyncOrchestrator","title":"<code>scripts.git_sync.sync_logic.SyncOrchestrator</code>","text":"<p>Enterprise-grade Git synchronization with preventive audit capabilities.</p> <p>Implements idempotent operations, comprehensive error handling, and structured logging for production-grade automation.</p> Source code in <code>scripts/git_sync/sync_logic.py</code> <pre><code>class SyncOrchestrator:\n    \"\"\"Enterprise-grade Git synchronization with preventive audit capabilities.\n\n    Implements idempotent operations, comprehensive error handling,\n    and structured logging for production-grade automation.\n    \"\"\"\n\n    def __init__(\n        self,\n        workspace_root: Path,\n        config: dict[str, Any],\n        *,\n        dry_run: bool = False,\n    ) -&gt; None:\n        \"\"\"Initialize the synchronization manager.\"\"\"\n        self.workspace_root = workspace_root.resolve()\n        self.config = config\n        self.dry_run = dry_run\n        self.steps: list[SyncStep] = []\n        self.sync_id = datetime.now(timezone.utc).strftime(\"%Y%m%d_%H%M%S\")\n        self.start_time = datetime.now(timezone.utc)\n\n        # Validate workspace is a Git repository\n        self._validate_git_repository()\n\n        logger.info(\"Initialized SyncOrchestrator (ID: %s)\", self.sync_id)\n        logger.info(\"Workspace: %s\", self.workspace_root)\n        logger.info(\"Dry run mode: %s\", self.dry_run)\n\n    def _validate_git_repository(self) -&gt; None:\n        \"\"\"Validate that workspace is a Git repository.\"\"\"\n        git_dir = self.workspace_root / \".git\"\n        if not git_dir.exists():\n            raise SyncError(f\"Not a Git repository: {self.workspace_root}\")\n\n    def _update_heartbeat(self, status: str) -&gt; None:\n        \"\"\"Update heartbeat file with current sync state.\n\n        Args:\n            status: Current status ('running', 'success', 'failed', 'crashed')\n\n        Note:\n            Failures in heartbeat updates are logged but do not interrupt sync.\n            The heartbeat is telemetry, not critical business logic.\n\n        \"\"\"\n        try:\n            heartbeat_path = self.workspace_root / \".git\" / \"sync_heartbeat\"\n\n            # Calculate duration since sync start\n            current_time = datetime.now(timezone.utc)\n            duration_seconds = (current_time - self.start_time).total_seconds()\n\n            # Get current branch if possible\n            try:\n                branch_result = self._run_command(\n                    [\"git\", \"branch\", \"--show-current\"],\n                    timeout=5,\n                    check=False,\n                )\n                if branch_result.returncode == 0:\n                    current_branch = branch_result.stdout.strip()\n                else:\n                    current_branch = \"unknown\"\n            except GitOperationError:\n                current_branch = \"unknown\"\n\n            # Build heartbeat data\n            heartbeat_data = {\n                \"sync_id\": self.sync_id,\n                \"status\": status,\n                \"timestamp\": current_time.isoformat(),\n                \"workspace\": str(self.workspace_root),\n                \"branch\": current_branch,\n                \"duration_seconds\": round(duration_seconds, 2),\n                \"phases_completed\": len(\n                    [s for s in self.steps if s.status == \"success\"],\n                ),\n                \"pid\": os.getpid(),\n            }\n\n            # Atomic write with fsync (POSIX compliant)\n            atomic_write_json(heartbeat_path, heartbeat_data, fsync=True)\n\n            logger.debug(\"Heartbeat updated: %s (status=%s)\", heartbeat_path, status)\n\n        except (OSError, GitOperationError) as e:\n            # Heartbeat failures are non-critical - log and continue\n            logger.warning(\"Failed to update heartbeat: %s\", e)\n\n    def _run_command(\n        self,\n        command: list[str],\n        timeout: int = 300,\n        capture_output: bool = True,\n        check: bool = True,\n        env: dict[str, str] | None = None,\n    ) -&gt; subprocess.CompletedProcess[str]:\n        \"\"\"Execute command with security best practices.\n\n        Args:\n            command: Command as list (never uses shell=True)  # noqa: subprocess\n            timeout: Command timeout in seconds\n            capture_output: Whether to capture stdout/stderr\n            check: Whether to raise on non-zero exit\n            env: Optional environment variables\n\n        Returns:\n            CompletedProcess instance\n\n        Raises:\n            GitOperationError: On command execution failure\n\n        \"\"\"\n        if self.dry_run:\n            logger.info(\"[DRY RUN] Would execute: %s\", \" \".join(command))\n            return subprocess.CompletedProcess(\n                args=command,\n                returncode=0,\n                stdout=\"[DRY RUN]\",\n                stderr=\"\",\n            )\n\n        try:\n            # Ensure we never use shell=True for security\n            env_vars = {**os.environ}\n            if env:\n                env_vars.update(env)\n\n            result = subprocess.run(  # nosec # noqa: subprocess\n                command,\n                cwd=self.workspace_root,\n                timeout=timeout,\n                capture_output=capture_output,\n                text=True,\n                check=check,\n                env=env_vars,\n            )\n\n            cmd_str = \" \".join(command)\n            debug_msg = f\"Command executed: {cmd_str} (exit code: {result.returncode})\"\n            logger.debug(debug_msg)\n            return result\n\n        except subprocess.CalledProcessError as e:\n            error_msg = (\n                f\"Command failed: {' '.join(command)} (exit code: {e.returncode})\"\n            )\n            if e.stderr:\n                error_msg += f\" - {e.stderr.strip()}\"\n            raise GitOperationError(error_msg) from e\n        except subprocess.TimeoutExpired as e:\n            error_msg = f\"Command timed out after {timeout}s: {' '.join(command)}\"\n            raise GitOperationError(error_msg) from e\n\n    def _check_git_status(self) -&gt; dict[str, Any]:\n        \"\"\"Check Git repository status.\"\"\"\n        step = SyncStep(\"git_status\", \"Checking Git repository status\")\n        step.start()\n        self.steps.append(step)\n\n        try:\n            # Check for uncommitted changes\n            result = self._run_command([\"git\", \"status\", \"--porcelain\"])\n            changed_files = [\n                line.strip()\n                for line in result.stdout.strip().split(\"\\n\")\n                if line.strip()\n            ]\n\n            # Check current branch\n            branch_result = self._run_command([\"git\", \"branch\", \"--show-current\"])\n            current_branch = branch_result.stdout.strip()\n\n            # Check if repository is clean\n            is_clean = len(changed_files) == 0\n\n            status_info = {\n                \"is_clean\": is_clean,\n                \"changed_files\": changed_files,\n                \"total_changes\": len(changed_files),\n                \"current_branch\": current_branch,\n            }\n\n            step.complete(status_info)\n            return status_info\n\n        except GitOperationError as e:\n            step.fail(str(e))\n            raise\n\n    def _run_code_audit(self) -&gt; dict[str, Any]:\n        \"\"\"Execute comprehensive code audit.\"\"\"\n        step = SyncStep(\"code_audit\", \"Running preventive code audit\")\n        step.start()\n        self.steps.append(step)\n\n        try:\n            # Check if audit script exists\n            audit_script = self.workspace_root / \"scripts\" / \"code_audit.py\"\n            if not audit_script.exists():\n                logger.warning(\"Code audit script not found, skipping audit\")\n                step.complete({\"status\": \"skipped\", \"reason\": \"audit_script_not_found\"})\n                return {\"passed\": True, \"status\": \"skipped\"}\n\n            # Execute audit with CI simulation\n            audit_command = [\n                sys.executable,\n                str(audit_script),\n                \"--output\",\n                \"json\",\n                \"--fail-on\",\n                self.config.get(\"audit_fail_threshold\", \"HIGH\"),\n            ]\n\n            result = self._run_command(\n                audit_command,\n                timeout=self.config.get(\"audit_timeout\", 300),\n                check=False,  # Don't raise on non-zero exit, we'll handle it\n            )\n\n            audit_passed = result.returncode == 0\n            audit_details = {\n                \"passed\": audit_passed,\n                \"exit_code\": result.returncode,\n                \"stdout\": result.stdout,\n                \"stderr\": result.stderr,\n            }\n\n            if audit_passed:\n                step.complete(audit_details)\n            else:\n                step.fail(\"Code audit failed\", audit_details)\n                if self.config.get(\"strict_audit\", True):\n                    raise AuditError(\n                        f\"Code audit failed with exit code {result.returncode}\",\n                    )\n\n            return audit_details\n\n        except (GitOperationError, AuditError) as e:\n            step.fail(str(e))\n            raise\n\n    def _apply_lint_fixes(self) -&gt; dict[str, Any]:\n        \"\"\"Apply automated lint fixes if available.\"\"\"\n        step = SyncStep(\"lint_fixes\", \"Applying automated lint fixes\")\n        step.start()\n        self.steps.append(step)\n\n        try:\n            # Check if lint fix script exists\n            lint_script = self.workspace_root / \"scripts\" / \"lint_fix.py\"\n            if not lint_script.exists():\n                step.complete({\"status\": \"skipped\", \"reason\": \"lint_script_not_found\"})\n                return {\"fixes_applied\": 0, \"status\": \"skipped\"}\n\n            # Execute lint fixes\n            lint_command = [sys.executable, str(lint_script), \"--auto-fix\"]\n\n            result = self._run_command(\n                lint_command,\n                timeout=self.config.get(\"lint_timeout\", 180),\n                check=False,\n            )\n\n            fixes_applied = 0\n            # Parse output to count fixes (implementation depends on lint_fix.py format)\n            if \"fixes applied\" in result.stdout.lower():\n                # Extract number from output\n                match = re.search(r\"(\\d+)\\s+fixes?\\s+applied\", result.stdout.lower())\n                if match:\n                    fixes_applied = int(match.group(1))\n\n            fix_details = {\n                \"fixes_applied\": fixes_applied,\n                \"exit_code\": result.returncode,\n                \"stdout\": result.stdout,\n                \"stderr\": result.stderr,\n            }\n\n            step.complete(fix_details)\n            return fix_details\n\n        except GitOperationError as e:\n            step.fail(str(e))\n            raise\n\n    def _generate_smart_commit_message(self, git_status: dict[str, Any]) -&gt; str:\n        \"\"\"Generate intelligent commit message based on changes.\"\"\"\n        changed_files = git_status.get(\"changed_files\", [])\n\n        # Analyze file types and changes\n        categories: dict[str, list[str]] = {\n            \"feat\": [],\n            \"fix\": [],\n            \"test\": [],\n            \"docs\": [],\n            \"chore\": [],\n            \"style\": [],\n            \"refactor\": [],\n        }\n\n        for file_change in changed_files:\n            # Parse Git status format (e.g., \"M  file.py\", \"A  newfile.py\")\n            if len(file_change) &lt; 3:\n                continue\n\n            status_code = file_change[0]  # M, A, D, etc.\n            filepath = file_change[3:]  # Skip status codes and space\n\n            # Categorize by path and content\n            if \"test\" in filepath.lower():\n                categories[\"test\"].append(filepath)\n            elif filepath.endswith(\".md\") or \"doc\" in filepath.lower():\n                categories[\"docs\"].append(filepath)\n            elif filepath.startswith(\"src/\") or filepath.endswith(\".py\"):\n                if status_code == \"A\":  # New file\n                    categories[\"feat\"].append(filepath)\n                else:\n                    categories[\"fix\"].append(filepath)  # Modified existing\n            elif \"script\" in filepath or filepath.startswith(\"scripts/\"):\n                categories[\"chore\"].append(filepath)\n            else:\n                categories[\"chore\"].append(filepath)\n\n        # Determine primary category\n        primary_category = \"chore\"  # Default\n        max_count = 0\n\n        for category, files in categories.items():\n            if len(files) &gt; max_count:\n                max_count = len(files)\n                primary_category = category\n\n        # Generate message\n        total_files = len(changed_files)\n        message_parts = [f\"{primary_category}: smart sync with preventive audit\"]\n\n        if total_files &gt; 0:\n            message_parts.append(f\"({total_files} files)\")\n\n        # Add fix information if available\n        if hasattr(self, \"_last_audit_result\"):\n            audit_result = getattr(self, \"_last_audit_result\", {})\n            if not audit_result.get(\"passed\", True):\n                message_parts.append(\"[audit-fixes]\")\n\n        return \" \".join(message_parts)\n\n    def _commit_and_push(self, git_status: dict[str, Any]) -&gt; dict[str, Any]:\n        \"\"\"Perform Git commit and push operations.\"\"\"\n        if git_status[\"is_clean\"]:\n            logger.info(\"Repository is clean, nothing to commit\")\n            return {\"status\": \"clean\", \"committed\": False}\n\n        # Add files to staging\n        add_step = SyncStep(\"git_add\", \"Adding files to Git staging area\")\n        add_step.start()\n        self.steps.append(add_step)\n\n        try:\n            # Use git add . but exclude sensitive files\n            self._run_command([\"git\", \"add\", \".\"])\n            add_step.complete({\"files_added\": len(git_status[\"changed_files\"])})\n\n        except GitOperationError as e:\n            add_step.fail(str(e))\n            raise\n\n        # Commit changes\n        commit_step = SyncStep(\"git_commit\", \"Creating Git commit\")\n        commit_step.start()\n        self.steps.append(commit_step)\n\n        try:\n            commit_message = self._generate_smart_commit_message(git_status)\n            self._run_command([\"git\", \"commit\", \"-m\", commit_message])\n\n            # Get commit hash\n            hash_result = self._run_command([\"git\", \"rev-parse\", \"HEAD\"])\n            commit_hash = hash_result.stdout.strip()\n\n            commit_details = {\n                \"message\": commit_message,\n                \"hash\": commit_hash,\n                \"files_committed\": len(git_status[\"changed_files\"]),\n            }\n\n            commit_step.complete(commit_details)\n\n        except GitOperationError as e:\n            commit_step.fail(str(e))\n            raise\n\n        # Push to remote\n        push_step = SyncStep(\"git_push\", \"Pushing to remote repository\")\n        push_step.start()\n        self.steps.append(push_step)\n\n        try:\n            # Get current branch for push\n            current_branch = git_status[\"current_branch\"]\n            self._run_command([\"git\", \"push\", \"origin\", current_branch])\n\n            push_details = {\n                \"branch\": current_branch,\n                \"commit_hash\": commit_hash,\n            }\n\n            push_step.complete(push_details)\n\n            return {\n                \"status\": \"success\",\n                \"committed\": True,\n                \"commit\": commit_details,\n                \"push\": push_details,\n            }\n\n        except GitOperationError as e:\n            push_step.fail(str(e))\n\n            # Rollback commit if push fails\n            logger.warning(\"Push failed, attempting to rollback commit\")\n            try:\n                self._run_command([\"git\", \"reset\", \"--soft\", \"HEAD~1\"])\n                logger.info(\"Successfully rolled back commit\")\n            except GitOperationError as rollback_error:\n                logger.error(\"Rollback failed: %s\", rollback_error)\n\n            raise\n\n    def _cleanup_repository(self) -&gt; None:\n        \"\"\"Perform repository cleanup operations.\"\"\"\n        cleanup_step = SyncStep(\"git_cleanup\", \"Cleaning up repository\")\n        cleanup_step.start()\n        self.steps.append(cleanup_step)\n\n        try:\n            cleanup_commands = [\n                [\"git\", \"gc\", \"--auto\"],\n                [\"git\", \"remote\", \"prune\", \"origin\"],\n            ]\n\n            cleanup_results = []\n            for cmd in cleanup_commands:\n                try:\n                    result = self._run_command(cmd, timeout=60, check=False)\n                    cleanup_results.append(\n                        {\n                            \"command\": \" \".join(cmd),\n                            \"success\": result.returncode == 0,\n                        },\n                    )\n                except GitOperationError:\n                    cleanup_results.append(\n                        {\n                            \"command\": \" \".join(cmd),\n                            \"success\": False,\n                        },\n                    )\n\n            cleanup_step.complete({\"operations\": cleanup_results})\n\n        except Exception as e:\n            cleanup_step.fail(str(e))\n            # Don't raise - cleanup failures are not critical\n\n    def _save_sync_report(self) -&gt; Path:\n        \"\"\"Save synchronization report to file.\"\"\"\n        report = {\n            \"metadata\": {\n                \"sync_id\": self.sync_id,\n                \"timestamp\": datetime.now(timezone.utc).isoformat(),\n                \"workspace\": str(self.workspace_root),\n                \"dry_run\": self.dry_run,\n                \"config\": self.config,\n            },\n            \"steps\": [step.to_dict() for step in self.steps],\n            \"summary\": {\n                \"total_steps\": len(self.steps),\n                \"successful_steps\": len(\n                    [s for s in self.steps if s.status == \"success\"],\n                ),\n                \"failed_steps\": len([s for s in self.steps if s.status == \"failed\"]),\n                \"total_duration\": sum(step._get_duration() for step in self.steps),\n            },\n        }\n\n        report_file = self.workspace_root / f\"sync_report_{self.sync_id}.json\"\n\n        try:\n            with report_file.open(\"w\", encoding=\"utf-8\") as f:\n                json.dump(report, f, indent=2, ensure_ascii=False)\n\n            logger.info(\"Sync report saved: %s\", report_file)\n            return report_file\n\n        except Exception as e:\n            logger.error(\"Failed to save sync report: %s\", e)\n            raise\n\n    def execute_sync(self) -&gt; bool:\n        \"\"\"Execute complete smart synchronization workflow.\n\n        Returns:\n            True if synchronization completed successfully, False otherwise.\n\n        \"\"\"\n        logger.info(\"\ud83d\ude80 Starting Smart Git Synchronization\")\n        logger.info(\"=\" * 60)\n\n        # Update heartbeat: sync started\n        self._update_heartbeat(\"running\")\n\n        try:\n            # Phase 1: Repository Status Check\n            logger.info(\"\ud83d\udccb PHASE 1: Repository Status Analysis\")\n            git_status = self._check_git_status()\n\n            # Protection: prevent direct push to main\n            current_branch = git_status.get(\"current_branch\")\n            if current_branch == \"main\":\n                logger.error(\"\ud83d\uded1 OPERA\u00c7\u00c3O PROIBIDA NA 'main'\")\n                logger.error(\"A branch 'main' est\u00e1 protegida por regras ('Cofre').\")\n                logger.error(\"Este script n\u00e3o pode fazer 'push' direto na 'main'.\")\n                logger.warning(\n                    \"Use o 'Fluxo de Trabalho (Chave Mestra)': Crie um branch, \"\n                    \"abra um PR e solicite um 'Bypass' do administrador.\",\n                )\n                raise SyncError(\"Tentativa de 'push' direto na 'main' protegida.\")\n\n            if git_status[\"is_clean\"]:\n                logger.info(\"Repository is clean, no changes to sync\")\n                self._save_sync_report()\n                return True\n\n            logger.info(\"Found %d changes to process\", git_status[\"total_changes\"])\n\n            # Phase 2: Code Quality and Security Audit\n            logger.info(\"\ud83d\udd0d PHASE 2: Preventive Code Audit\")\n            audit_result = self._run_code_audit()\n            self._last_audit_result = audit_result  # Store for commit message\n\n            # Phase 3: Automated Fixes (if audit found issues)\n            if not audit_result.get(\"passed\", True) and self.config.get(\n                \"auto_fix_enabled\",\n                True,\n            ):\n                logger.info(\"\ud83d\udd27 PHASE 3: Automated Lint Fixes\")\n                fix_result = self._apply_lint_fixes()\n                logger.info(\n                    \"Applied %d automated fixes\",\n                    fix_result.get(\"fixes_applied\", 0),\n                )\n\n            # Phase 4: Git Operations\n            logger.info(\"\ud83d\udce4 PHASE 4: Git Commit and Push\")\n            git_result = self._commit_and_push(git_status)\n\n            # Phase 5: Cleanup\n            if self.config.get(\"cleanup_enabled\", True):\n                logger.info(\"\ud83e\uddf9 PHASE 5: Repository Cleanup\")\n                self._cleanup_repository()\n\n            # Save report and finalize\n            self._save_sync_report()\n\n            logger.info(\"=\" * 60)\n            logger.info(\"\u2705 Smart Git Synchronization completed successfully!\")\n\n            if git_result.get(\"committed\"):\n                commit_hash = git_result.get(\"commit\", {}).get(\"hash\", \"unknown\")\n                logger.info(\"\ud83d\udce6 Commit: %s\", commit_hash[:8])\n                logger.info(\"\ud83c\udf33 Branch: %s\", git_status[\"current_branch\"])\n\n            # Update heartbeat: sync successful\n            self._update_heartbeat(\"success\")\n\n            return True\n\n        except (SyncError, GitOperationError, AuditError) as e:\n            logger.error(\"Synchronization failed: %s\", e)\n            self._update_heartbeat(\"failed\")\n            self._save_sync_report()\n            return False\n\n        except Exception as e:\n            logger.critical(\"UNEXPECTED BUG: %s\", e, exc_info=True)\n            self._update_heartbeat(\"crashed\")\n            self._save_sync_report()\n            raise\n</code></pre>"},{"location":"reference/git_sync/#scripts.git_sync.sync_logic.SyncOrchestrator.__init__","title":"<code>__init__(workspace_root, config, *, dry_run=False)</code>","text":"<p>Initialize the synchronization manager.</p> Source code in <code>scripts/git_sync/sync_logic.py</code> <pre><code>def __init__(\n    self,\n    workspace_root: Path,\n    config: dict[str, Any],\n    *,\n    dry_run: bool = False,\n) -&gt; None:\n    \"\"\"Initialize the synchronization manager.\"\"\"\n    self.workspace_root = workspace_root.resolve()\n    self.config = config\n    self.dry_run = dry_run\n    self.steps: list[SyncStep] = []\n    self.sync_id = datetime.now(timezone.utc).strftime(\"%Y%m%d_%H%M%S\")\n    self.start_time = datetime.now(timezone.utc)\n\n    # Validate workspace is a Git repository\n    self._validate_git_repository()\n\n    logger.info(\"Initialized SyncOrchestrator (ID: %s)\", self.sync_id)\n    logger.info(\"Workspace: %s\", self.workspace_root)\n    logger.info(\"Dry run mode: %s\", self.dry_run)\n</code></pre>"},{"location":"reference/git_sync/#scripts.git_sync.sync_logic.SyncOrchestrator.execute_sync","title":"<code>execute_sync()</code>","text":"<p>Execute complete smart synchronization workflow.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if synchronization completed successfully, False otherwise.</p> Source code in <code>scripts/git_sync/sync_logic.py</code> <pre><code>def execute_sync(self) -&gt; bool:\n    \"\"\"Execute complete smart synchronization workflow.\n\n    Returns:\n        True if synchronization completed successfully, False otherwise.\n\n    \"\"\"\n    logger.info(\"\ud83d\ude80 Starting Smart Git Synchronization\")\n    logger.info(\"=\" * 60)\n\n    # Update heartbeat: sync started\n    self._update_heartbeat(\"running\")\n\n    try:\n        # Phase 1: Repository Status Check\n        logger.info(\"\ud83d\udccb PHASE 1: Repository Status Analysis\")\n        git_status = self._check_git_status()\n\n        # Protection: prevent direct push to main\n        current_branch = git_status.get(\"current_branch\")\n        if current_branch == \"main\":\n            logger.error(\"\ud83d\uded1 OPERA\u00c7\u00c3O PROIBIDA NA 'main'\")\n            logger.error(\"A branch 'main' est\u00e1 protegida por regras ('Cofre').\")\n            logger.error(\"Este script n\u00e3o pode fazer 'push' direto na 'main'.\")\n            logger.warning(\n                \"Use o 'Fluxo de Trabalho (Chave Mestra)': Crie um branch, \"\n                \"abra um PR e solicite um 'Bypass' do administrador.\",\n            )\n            raise SyncError(\"Tentativa de 'push' direto na 'main' protegida.\")\n\n        if git_status[\"is_clean\"]:\n            logger.info(\"Repository is clean, no changes to sync\")\n            self._save_sync_report()\n            return True\n\n        logger.info(\"Found %d changes to process\", git_status[\"total_changes\"])\n\n        # Phase 2: Code Quality and Security Audit\n        logger.info(\"\ud83d\udd0d PHASE 2: Preventive Code Audit\")\n        audit_result = self._run_code_audit()\n        self._last_audit_result = audit_result  # Store for commit message\n\n        # Phase 3: Automated Fixes (if audit found issues)\n        if not audit_result.get(\"passed\", True) and self.config.get(\n            \"auto_fix_enabled\",\n            True,\n        ):\n            logger.info(\"\ud83d\udd27 PHASE 3: Automated Lint Fixes\")\n            fix_result = self._apply_lint_fixes()\n            logger.info(\n                \"Applied %d automated fixes\",\n                fix_result.get(\"fixes_applied\", 0),\n            )\n\n        # Phase 4: Git Operations\n        logger.info(\"\ud83d\udce4 PHASE 4: Git Commit and Push\")\n        git_result = self._commit_and_push(git_status)\n\n        # Phase 5: Cleanup\n        if self.config.get(\"cleanup_enabled\", True):\n            logger.info(\"\ud83e\uddf9 PHASE 5: Repository Cleanup\")\n            self._cleanup_repository()\n\n        # Save report and finalize\n        self._save_sync_report()\n\n        logger.info(\"=\" * 60)\n        logger.info(\"\u2705 Smart Git Synchronization completed successfully!\")\n\n        if git_result.get(\"committed\"):\n            commit_hash = git_result.get(\"commit\", {}).get(\"hash\", \"unknown\")\n            logger.info(\"\ud83d\udce6 Commit: %s\", commit_hash[:8])\n            logger.info(\"\ud83c\udf33 Branch: %s\", git_status[\"current_branch\"])\n\n        # Update heartbeat: sync successful\n        self._update_heartbeat(\"success\")\n\n        return True\n\n    except (SyncError, GitOperationError, AuditError) as e:\n        logger.error(\"Synchronization failed: %s\", e)\n        self._update_heartbeat(\"failed\")\n        self._save_sync_report()\n        return False\n\n    except Exception as e:\n        logger.critical(\"UNEXPECTED BUG: %s\", e, exc_info=True)\n        self._update_heartbeat(\"crashed\")\n        self._save_sync_report()\n        raise\n</code></pre>"},{"location":"reference/git_sync/#modelos-de-dados","title":"Modelos de Dados","text":""},{"location":"reference/git_sync/#scripts.git_sync.models","title":"<code>scripts.git_sync.models</code>","text":"<p>Data models for the Git synchronization system.</p>"},{"location":"reference/git_sync/#scripts.git_sync.models.SyncStep","title":"<code>SyncStep</code>","text":"<p>Represents a single synchronization step with metadata.</p> Source code in <code>scripts/git_sync/models.py</code> <pre><code>class SyncStep:\n    \"\"\"Represents a single synchronization step with metadata.\"\"\"\n\n    def __init__(self, name: str, description: str) -&gt; None:\n        \"\"\"Initialize a sync step with name and description.\"\"\"\n        self.name = name\n        self.description = description\n        self.start_time: datetime | None = None\n        self.end_time: datetime | None = None\n        self.status: str = \"pending\"\n        self.error: str | None = None\n        self.details: dict[str, Any] = {}\n\n    def start(self) -&gt; None:\n        \"\"\"Mark step as started.\"\"\"\n        self.start_time = datetime.now(timezone.utc)\n        self.status = \"running\"\n        logger.info(\"\ud83d\udd04 Starting: %s - %s\", self.name, self.description)\n\n    def complete(self, details: dict[str, Any] | None = None) -&gt; None:\n        \"\"\"Mark step as completed successfully.\"\"\"\n        self.end_time = datetime.now(timezone.utc)\n        self.status = \"success\"\n        if details:\n            self.details.update(details)\n\n        duration = self._get_duration()\n        logger.info(\"\u2705 Completed: %s (%.2fs)\", self.name, duration)\n\n    def fail(self, error: str, details: dict[str, Any] | None = None) -&gt; None:\n        \"\"\"Mark step as failed.\"\"\"\n        self.end_time = datetime.now(timezone.utc)\n        self.status = \"failed\"\n        self.error = error\n        if details:\n            self.details.update(details)\n\n        duration = self._get_duration()\n        logger.error(\"\u274c Failed: %s (%.2fs) - %s\", self.name, duration, error)\n\n    def _get_duration(self) -&gt; float:\n        \"\"\"Calculate step duration in seconds.\"\"\"\n        if self.start_time and self.end_time:\n            return (self.end_time - self.start_time).total_seconds()\n        return 0.0\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Convert step to dictionary for serialization.\"\"\"\n        return {\n            \"name\": self.name,\n            \"description\": self.description,\n            \"status\": self.status,\n            \"start_time\": self.start_time.isoformat() if self.start_time else None,\n            \"end_time\": self.end_time.isoformat() if self.end_time else None,\n            \"duration\": self._get_duration(),\n            \"error\": self.error,\n            \"details\": self.details,\n        }\n</code></pre>"},{"location":"reference/git_sync/#scripts.git_sync.models.SyncStep.__init__","title":"<code>__init__(name, description)</code>","text":"<p>Initialize a sync step with name and description.</p> Source code in <code>scripts/git_sync/models.py</code> <pre><code>def __init__(self, name: str, description: str) -&gt; None:\n    \"\"\"Initialize a sync step with name and description.\"\"\"\n    self.name = name\n    self.description = description\n    self.start_time: datetime | None = None\n    self.end_time: datetime | None = None\n    self.status: str = \"pending\"\n    self.error: str | None = None\n    self.details: dict[str, Any] = {}\n</code></pre>"},{"location":"reference/git_sync/#scripts.git_sync.models.SyncStep.complete","title":"<code>complete(details=None)</code>","text":"<p>Mark step as completed successfully.</p> Source code in <code>scripts/git_sync/models.py</code> <pre><code>def complete(self, details: dict[str, Any] | None = None) -&gt; None:\n    \"\"\"Mark step as completed successfully.\"\"\"\n    self.end_time = datetime.now(timezone.utc)\n    self.status = \"success\"\n    if details:\n        self.details.update(details)\n\n    duration = self._get_duration()\n    logger.info(\"\u2705 Completed: %s (%.2fs)\", self.name, duration)\n</code></pre>"},{"location":"reference/git_sync/#scripts.git_sync.models.SyncStep.fail","title":"<code>fail(error, details=None)</code>","text":"<p>Mark step as failed.</p> Source code in <code>scripts/git_sync/models.py</code> <pre><code>def fail(self, error: str, details: dict[str, Any] | None = None) -&gt; None:\n    \"\"\"Mark step as failed.\"\"\"\n    self.end_time = datetime.now(timezone.utc)\n    self.status = \"failed\"\n    self.error = error\n    if details:\n        self.details.update(details)\n\n    duration = self._get_duration()\n    logger.error(\"\u274c Failed: %s (%.2fs) - %s\", self.name, duration, error)\n</code></pre>"},{"location":"reference/git_sync/#scripts.git_sync.models.SyncStep.start","title":"<code>start()</code>","text":"<p>Mark step as started.</p> Source code in <code>scripts/git_sync/models.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Mark step as started.\"\"\"\n    self.start_time = datetime.now(timezone.utc)\n    self.status = \"running\"\n    logger.info(\"\ud83d\udd04 Starting: %s - %s\", self.name, self.description)\n</code></pre>"},{"location":"reference/git_sync/#scripts.git_sync.models.SyncStep.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert step to dictionary for serialization.</p> Source code in <code>scripts/git_sync/models.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Convert step to dictionary for serialization.\"\"\"\n    return {\n        \"name\": self.name,\n        \"description\": self.description,\n        \"status\": self.status,\n        \"start_time\": self.start_time.isoformat() if self.start_time else None,\n        \"end_time\": self.end_time.isoformat() if self.end_time else None,\n        \"duration\": self._get_duration(),\n        \"error\": self.error,\n        \"details\": self.details,\n    }\n</code></pre>"},{"location":"reference/git_sync/#excecoes","title":"Exce\u00e7\u00f5es","text":""},{"location":"reference/git_sync/#scripts.git_sync.exceptions","title":"<code>scripts.git_sync.exceptions</code>","text":"<p>Custom exceptions for the Git synchronization system.</p>"},{"location":"reference/git_sync/#scripts.git_sync.exceptions.AuditError","title":"<code>AuditError</code>","text":"<p>               Bases: <code>SyncError</code></p> <p>Exception for audit failures.</p> Source code in <code>scripts/git_sync/exceptions.py</code> <pre><code>class AuditError(SyncError):\n    \"\"\"Exception for audit failures.\"\"\"\n</code></pre>"},{"location":"reference/git_sync/#scripts.git_sync.exceptions.GitOperationError","title":"<code>GitOperationError</code>","text":"<p>               Bases: <code>SyncError</code></p> <p>Exception for Git operation failures.</p> Source code in <code>scripts/git_sync/exceptions.py</code> <pre><code>class GitOperationError(SyncError):\n    \"\"\"Exception for Git operation failures.\"\"\"\n</code></pre>"},{"location":"reference/git_sync/#scripts.git_sync.exceptions.SyncError","title":"<code>SyncError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for synchronization errors.</p> Source code in <code>scripts/git_sync/exceptions.py</code> <pre><code>class SyncError(Exception):\n    \"\"\"Base exception for synchronization errors.\"\"\"\n</code></pre>"},{"location":"reference/git_sync/#configuracao","title":"Configura\u00e7\u00e3o","text":"<p>Pr\u00f3ximos Passos</p> <p>Esta p\u00e1gina ser\u00e1 automaticamente populada com a documenta\u00e7\u00e3o completa das classes e fun\u00e7\u00f5es quando o MkDocs for executado com as depend\u00eancias instaladas.</p> <p>Documenta\u00e7\u00e3o Adicional</p> <p>Para um guia completo de uso, consulte o Smart Git Sync Guide.</p>"},{"location":"reference/git_sync/#scripts.git_sync.config","title":"<code>scripts.git_sync.config</code>","text":"<p>Configuration management for the Git synchronization system.</p>"},{"location":"reference/git_sync/#scripts.git_sync.config.load_config","title":"<code>load_config(config_path=None)</code>","text":"<p>Load configuration with sensible defaults.</p> Source code in <code>scripts/git_sync/config.py</code> <pre><code>def load_config(config_path: Path | None = None) -&gt; dict[str, Any]:\n    \"\"\"Load configuration with sensible defaults.\"\"\"\n    default_config = {\n        \"audit_enabled\": True,\n        \"audit_timeout\": 300,\n        \"audit_fail_threshold\": \"HIGH\",\n        \"strict_audit\": True,\n        \"auto_fix_enabled\": True,\n        \"lint_timeout\": 180,\n        \"cleanup_enabled\": True,\n        \"git_timeout\": 120,\n    }\n\n    if config_path and config_path.exists():\n        try:\n            with open(config_path, encoding=\"utf-8\") as f:\n                user_config = yaml.safe_load(f)\n                default_config.update(user_config)\n                logger.info(f\"Loaded configuration from {config_path}\")\n        except Exception as e:\n            logger.warning(f\"Failed to load config from {config_path}: {e}\")\n\n    return default_config\n</code></pre>"}]}