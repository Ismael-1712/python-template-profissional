"""Test Dependency Guardian Resilience and Fallback Mechanisms.

This module validates the resilience features of the Dependency Guardian,
specifically the fallback to sys.executable when the provided python_exec
is invalid or not found.

Context:
    Exit Code 127 in CI was caused by attempting to use .venv/bin/python
    before the virtual environment was created. The Guardian must gracefully
    handle invalid python_exec and fallback to sys.executable.

Architecture:
    - Fallback validation: Invalid python_exec triggers automatic fallback
    - Warning emission: User is notified when fallback occurs
    - No failure: System continues with alternative interpreter
"""

import sys
from pathlib import Path
from unittest.mock import MagicMock, patch

import pytest

from scripts.core.dependency_guardian import DependencyGuardian


class TestDependencyGuardianResilience:
    """Validates fallback mechanisms for invalid Python executables."""

    @pytest.fixture
    def guardian(self, tmp_path: Path) -> DependencyGuardian:
        """Create a DependencyGuardian instance with temporary directory."""
        return DependencyGuardian(tmp_path)

    @pytest.fixture
    def mock_requirements_files(self, tmp_path: Path) -> tuple[Path, Path]:
        """Create mock .in and .txt files for testing."""
        in_file = tmp_path / "dev.in"
        txt_file = tmp_path / "dev.txt"

        in_file.write_text("pytest==9.0.0\n", encoding="utf-8")
        txt_file.write_text(
            "# Autogenerated by pip-compile\npytest==9.0.0\n",
            encoding="utf-8",
        )

        return in_file, txt_file

    def test_fallback_to_sys_executable_when_python_exec_not_found(
        self,
        guardian: DependencyGuardian,
        mock_requirements_files: tuple[Path, Path],
        capsys: pytest.CaptureFixture,
    ) -> None:
        """Test fallback to sys.executable when python_exec doesn't exist.

        Scenario:
            - User provides python_exec pointing to non-existent file
            - Guardian attempts validation but executable not found
            - System falls back to sys.executable automatically
            - Warning message emitted to stdout

        Expected Behavior:
            - No exception raised
            - Warning printed to console
            - Validation continues with sys.executable
        """
        # Arrange: Invalid python executable path
        invalid_python = "/nonexistent/path/to/python"

        # Mock pip-tools availability check to succeed for sys.executable
        with patch("subprocess.run") as mock_run:
            # First call: Check if invalid_python works (should fail)
            # Second call: Check piptools on sys.executable (should succeed)
            # Third call: pip-compile execution (should succeed)
            mock_run.side_effect = [
                MagicMock(returncode=1, stderr="File not found"),  # Invalid exec
                MagicMock(returncode=0),  # piptools check on sys.executable
                MagicMock(returncode=0),  # pip-compile success
            ]

            # Act: Call validate_deep_consistency with invalid python_exec
            is_valid, diff = guardian.validate_deep_consistency(
                "dev",
                python_exec=invalid_python,
            )

        # Assert: Warning emitted
        captured = capsys.readouterr()
        assert "⚠️" in captured.err or "Warning" in captured.err
        assert "fallback" in captured.err.lower() or "sys.executable" in captured.err

    def test_fallback_preserves_functionality(
        self,
        guardian: DependencyGuardian,
        mock_requirements_files: tuple[Path, Path],
    ) -> None:
        """Test that fallback to sys.executable preserves validation logic.

        Scenario:
            - python_exec is invalid
            - Fallback to sys.executable triggered
            - Validation logic still executes correctly
            - Result is consistent with direct sys.executable usage

        Expected Behavior:
            - Same result as calling with sys.executable directly
            - No data loss or corruption
            - Validation accuracy maintained
        """
        invalid_python = "/tmp/nonexistent_python"

        with patch("subprocess.run") as mock_run:
            # Simulate fallback scenario
            mock_run.side_effect = [
                MagicMock(returncode=1),  # Invalid python check fails
                MagicMock(returncode=0),  # piptools check succeeds
                MagicMock(returncode=0, stdout="pytest==9.0.0\n"),  # pip-compile
            ]

            # Call with invalid python (should fallback)
            result_with_fallback, diff_with_fallback = (
                guardian.validate_deep_consistency(
                    "dev",
                    python_exec=invalid_python,
                )
            )

        # Reset mock
        with patch("subprocess.run") as mock_run:
            mock_run.side_effect = [
                MagicMock(returncode=0),  # piptools check
                MagicMock(returncode=0, stdout="pytest==9.0.0\n"),  # pip-compile
            ]

            # Call with sys.executable directly
            result_direct, diff_direct = guardian.validate_deep_consistency(
                "dev",
                python_exec=sys.executable,
            )

        # Assert: Results should be equivalent
        assert result_with_fallback == result_direct
        assert diff_with_fallback == diff_direct

    def test_no_fallback_when_python_exec_valid(
        self,
        guardian: DependencyGuardian,
        mock_requirements_files: tuple[Path, Path],
        capsys: pytest.CaptureFixture,
    ) -> None:
        """Test that fallback does NOT occur when python_exec is valid.

        Scenario:
            - python_exec points to valid executable
            - Guardian validates successfully
            - No fallback triggered
            - No warning emitted

        Expected Behavior:
            - Uses provided python_exec
            - No fallback message in logs
            - Normal execution path
        """
        valid_python = sys.executable

        with patch("subprocess.run") as mock_run:
            mock_run.side_effect = [
                MagicMock(returncode=0),  # Valid python check succeeds
                MagicMock(returncode=0),  # piptools check
                MagicMock(returncode=0, stdout="pytest==9.0.0\n"),  # pip-compile
            ]

            guardian.validate_deep_consistency("dev", python_exec=valid_python)

        captured = capsys.readouterr()
        # Should NOT contain fallback messages
        assert "fallback" not in captured.err.lower()

    def test_fallback_with_none_python_exec(
        self,
        guardian: DependencyGuardian,
        mock_requirements_files: tuple[Path, Path],
    ) -> None:
        """Test that None python_exec defaults to sys.executable (existing behavior).

        Scenario:
            - python_exec is None
            - Guardian uses sys.executable directly
            - No validation of python_exec needed

        Expected Behavior:
            - Uses sys.executable without validation
            - Normal execution
        """
        with patch("subprocess.run") as mock_run:
            mock_run.side_effect = [
                MagicMock(returncode=0),  # piptools check
                MagicMock(returncode=0, stdout="pytest==9.0.0\n"),  # pip-compile
            ]

            is_valid, diff = guardian.validate_deep_consistency(
                "dev",
                python_exec=None,  # Should use sys.executable
            )

        # Assert: No failure, used sys.executable
        assert isinstance(is_valid, bool)
